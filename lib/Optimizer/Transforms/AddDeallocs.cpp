/*************************************************************** -*- C++ -*- ***
 * Copyright (c) 2022 - 2023 NVIDIA Corporation & Affiliates.                  *
 * All rights reserved.                                                        *
 *                                                                             *
 * This source code and the accompanying materials are made available under    *
 * the terms of the Apache License 2.0 which accompanies this distribution.    *
 *******************************************************************************/

#include "PassDetails.h"
#include "cudaq/Optimizer/Dialect/Quake/QuakeOps.h"
#include "cudaq/Optimizer/Transforms/Passes.h"
#include "cudaq/Todo.h"
#include "mlir/IR/Dominance.h"
#include "mlir/Transforms/DialectConversion.h"
#include "mlir/Transforms/Passes.h"

using namespace mlir;

namespace {

class QuakeAddDeallocsPass
    : public cudaq::opt::QuakeAddDeallocsBase<QuakeAddDeallocsPass> {
public:
  // TODO: This is currently a very basic pass for inserting the deallocations.
  // The Buffer Deallocation Pass in mlir/lib/Dialect/Bufferization/Transforms
  // is a good example of achieving similar results for buffer deallocation.
  // Currently it is unclear what degree of complexity that we want to support,
  // and this pass works for all of our current examples. We can expand this
  // pass as needed to deal with quake qvector allocations in programs with more
  // sophisticated control flow.
  //
  // For example, if we allocate a QVec in an if statement body, then the
  // returns will not be dominated by the alloc and no dealloc will be
  // generated by this pass. Following a scope model, the QVec should be
  // deallocated when the compound statement block exits (along any path).
  void runOnOperation() override {
    func::FuncOp funcOp = getOperation();
    if (!funcOp || funcOp.empty())
      return;

    DominanceInfo domInfo(funcOp);
    auto builder = OpBuilder::atBlockBegin(&funcOp.getBody().front());
    SmallVector<Operation *> termOps;
    SmallVector<Operation *> allocOps;

    // Find all allocas and returns in the function.
    for (auto &operation : funcOp.getOps()) {
      if (isa<quake::AllocaOp>(operation))
        allocOps.push_back(&operation);
      else if (isa<func::ReturnOp>(operation))
        termOps.push_back(&operation);
    }

    // Lambda that helps us look and see if the
    // qreg from an alloca op is already deallocated
    auto deallocated = [](quake::AllocaOp op) {
      auto qreg = op.getResult();
      for (auto user : qreg.getUsers()) {
        if (isa<quake::DeallocOp>(user)) {
          return true;
        }
      }
      return false;
    };

    // Add a dealloc before each return forall allocs that dominate the return.
    for (auto term : termOps)
      for (auto alloc : allocOps)
        if (domInfo.dominates(alloc, term)) {
          builder.setInsertionPoint(term);
          auto qAlloc = cast<quake::AllocaOp>(alloc);
          if (!deallocated(qAlloc)) {
            builder.create<quake::DeallocOp>(alloc->getLoc(),
                                             qAlloc.getResult());
          }
        }
  }
};

} // namespace

std::unique_ptr<mlir::Pass> cudaq::opt::createQuakeAddDeallocs() {
  return std::make_unique<QuakeAddDeallocsPass>();
}
