<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUDA-Q: nvqir::CircuitSimulatorBase&lt; ScalarType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CUDA-Q
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nvqir</b></li><li class="navelem"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">CircuitSimulatorBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">nvqir::CircuitSimulatorBase&lt; ScalarType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html" title="The CircuitSimulatorBase is the type that is meant to be subclassed for new simulation strategies....">CircuitSimulatorBase</a> is the type that is meant to be subclassed for new simulation strategies. The separation of <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a> from <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html" title="The CircuitSimulatorBase is the type that is meant to be subclassed for new simulation strategies....">CircuitSimulatorBase</a> allows simulation sub-types to specify the floating point precision for the simulation.  
 <a href="classnvqir_1_1CircuitSimulatorBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CircuitSimulator_8h_source.html">CircuitSimulator.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html">GateApplicationTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html" title="A GateApplicationTask consists of a matrix describing the quantum operation, a set of possible contro...">GateApplicationTask</a> consists of a matrix describing the quantum operation, a set of possible control qubit indices, and a set of target indices.  <a href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa410e397865a1043b063035416e03e3"><td class="memItemLeft" align="right" valign="top"><a id="aaa410e397865a1043b063035416e03e3" name="aaa410e397865a1043b063035416e03e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CircuitSimulatorBase</b> ()=default</td></tr>
<tr class="memdesc:aaa410e397865a1043b063035416e03e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor. <br /></td></tr>
<tr class="separator:aaa410e397865a1043b063035416e03e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad947de50f30664accb67121a1fe360ea"><td class="memItemLeft" align="right" valign="top"><a id="ad947de50f30664accb67121a1fe360ea" name="ad947de50f30664accb67121a1fe360ea"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~CircuitSimulatorBase</b> ()=default</td></tr>
<tr class="memdesc:ad947de50f30664accb67121a1fe360ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor. <br /></td></tr>
<tr class="separator:ad947de50f30664accb67121a1fe360ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc00ca0015d1a941ee5974327f47826"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a3cc00ca0015d1a941ee5974327f47826">createStateFromData</a> (const cudaq::state_data &amp;data) override</td></tr>
<tr class="memdesc:a3cc00ca0015d1a941ee5974327f47826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a simulation-specific SimulationState instance from a user-provided data set.  <br /></td></tr>
<tr class="separator:a3cc00ca0015d1a941ee5974327f47826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95ee18d416e23546aa01ef4d00722d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ae95ee18d416e23546aa01ef4d00722d5">setNoiseModel</a> (<a class="el" href="classcudaq_1_1noise__model.html">cudaq::noise_model</a> &amp;noise) override</td></tr>
<tr class="memdesc:ae95ee18d416e23546aa01ef4d00722d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current noise model to consider when simulating the state. This should be overridden by simulation strategies that support noise modeling.  <br /></td></tr>
<tr class="separator:ae95ee18d416e23546aa01ef4d00722d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52476e6ee21a3921dd6046ab4d3678e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudaq_1_1observe__result.html">cudaq::observe_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aa52476e6ee21a3921dd6046ab4d3678e">observe</a> (const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;term) override</td></tr>
<tr class="memdesc:aa52476e6ee21a3921dd6046ab4d3678e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the expected value of the given spin op with respect to the current state, &lt;psi | H | psi&gt;.  <br /></td></tr>
<tr class="separator:aa52476e6ee21a3921dd6046ab4d3678e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985f3ea7ac944dba1bc7097ca3dc865b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a985f3ea7ac944dba1bc7097ca3dc865b">allocateQubit</a> () override</td></tr>
<tr class="memdesc:a985f3ea7ac944dba1bc7097ca3dc865b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a single qubit, return the qubit as a logical index.  <br /></td></tr>
<tr class="separator:a985f3ea7ac944dba1bc7097ca3dc865b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac752abf42c181cec2c4171ef5258912f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ac752abf42c181cec2c4171ef5258912f">allocateQubits</a> (std::size_t count, const void *state=nullptr, cudaq::simulation_precision precision=cudaq::simulation_precision::fp32) override</td></tr>
<tr class="memdesc:ac752abf42c181cec2c4171ef5258912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <code>count</code> qubits.  <br /></td></tr>
<tr class="separator:ac752abf42c181cec2c4171ef5258912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f327c013941fab7971299990658f9d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a0f327c013941fab7971299990658f9d9">allocateQubits</a> (std::size_t count, const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> *state) override</td></tr>
<tr class="memdesc:a0f327c013941fab7971299990658f9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <code>count</code> qubits in a specific state.  <br /></td></tr>
<tr class="separator:a0f327c013941fab7971299990658f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fd3292dbbbfefb2b7ed9253fd55a05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a54fd3292dbbbfefb2b7ed9253fd55a05">deallocate</a> (const std::size_t qubitIdx) override</td></tr>
<tr class="memdesc:a54fd3292dbbbfefb2b7ed9253fd55a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the qubit with give index.  <br /></td></tr>
<tr class="separator:a54fd3292dbbbfefb2b7ed9253fd55a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21b6d1a25fe767fc492fc700323d0c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ae21b6d1a25fe767fc492fc700323d0c5">deallocateQubits</a> (const std::vector&lt; std::size_t &gt; &amp;qubits) override</td></tr>
<tr class="memdesc:ae21b6d1a25fe767fc492fc700323d0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate all requested qubits. If the number of qubits is equal to the number of allocated qubits, then clear the entire state at once.  <br /></td></tr>
<tr class="separator:ae21b6d1a25fe767fc492fc700323d0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c85f8f92fcc5a6bdf8c6ba73a4339"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a3c8c85f8f92fcc5a6bdf8c6ba73a4339">resetExecutionContext</a> () override</td></tr>
<tr class="memdesc:a3c8c85f8f92fcc5a6bdf8c6ba73a4339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the current execution context.  <br /></td></tr>
<tr class="separator:a3c8c85f8f92fcc5a6bdf8c6ba73a4339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5e6f033833c8f5145f91c3ec164634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aed5e6f033833c8f5145f91c3ec164634">setExecutionContext</a> (<a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *context) override</td></tr>
<tr class="memdesc:aed5e6f033833c8f5145f91c3ec164634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the execution context.  <br /></td></tr>
<tr class="separator:aed5e6f033833c8f5145f91c3ec164634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b7d9f193338ffc2c5a30fa5e877d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a00b7d9f193338ffc2c5a30fa5e877d8d">getExecutionContext</a> () override</td></tr>
<tr class="memdesc:a00b7d9f193338ffc2c5a30fa5e877d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current execution context.  <br /></td></tr>
<tr class="separator:a00b7d9f193338ffc2c5a30fa5e877d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e863f641e7f9254e7fa800cd8c96dd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a9e863f641e7f9254e7fa800cd8c96dd4">applyCustomOperation</a> (const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;matrix, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; std::size_t &gt; &amp;targets, const std::string_view customName) override</td></tr>
<tr class="memdesc:a9e863f641e7f9254e7fa800cd8c96dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a custom quantum operation.  <br /></td></tr>
<tr class="separator:a9e863f641e7f9254e7fa800cd8c96dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a75f48c5397d53c0b74a42262773b60"><td class="memTemplParams" colspan="2"><a id="a9a75f48c5397d53c0b74a42262773b60" name="a9a75f48c5397d53c0b74a42262773b60"></a>
template&lt;typename QuantumOperation &gt; </td></tr>
<tr class="memitem:a9a75f48c5397d53c0b74a42262773b60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enqueueQuantumOperation</b> (const std::vector&lt; ScalarType &gt; &amp;angles, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; std::size_t &gt; &amp;targets)</td></tr>
<tr class="separator:a9a75f48c5397d53c0b74a42262773b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a80d89bcaf9d443b33089508ae1280b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a9a80d89bcaf9d443b33089508ae1280b">u2</a> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx) override</td></tr>
<tr class="separator:a9a80d89bcaf9d443b33089508ae1280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e26d8a3ab86cf118d0d060f28ce26f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a6e26d8a3ab86cf118d0d060f28ce26f1">u3</a> (const double theta, const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx) override</td></tr>
<tr class="separator:a6e26d8a3ab86cf118d0d060f28ce26f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b3ae37690dc768845aa86b72fe883f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a31b3ae37690dc768845aa86b72fe883f">phased_rx</a> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx) override</td></tr>
<tr class="separator:a31b3ae37690dc768845aa86b72fe883f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92596e1a3c470048b6443f5e44164fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a92596e1a3c470048b6443f5e44164fc9">swap</a> (const std::vector&lt; std::size_t &gt; &amp;ctrlBits, const std::size_t srcIdx, const std::size_t tgtIdx) override</td></tr>
<tr class="memdesc:a92596e1a3c470048b6443f5e44164fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a general multi-control swap gate.  <br /></td></tr>
<tr class="separator:a92596e1a3c470048b6443f5e44164fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0944e6a666d0e436ecf2e927e2901dbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a0944e6a666d0e436ecf2e927e2901dbd">mz</a> (const std::size_t qubitIdx) override</td></tr>
<tr class="memdesc:a0944e6a666d0e436ecf2e927e2901dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the qubit with given index.  <br /></td></tr>
<tr class="separator:a0944e6a666d0e436ecf2e927e2901dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76554791ab3f3710de84ab86cacd45e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aa76554791ab3f3710de84ab86cacd45e">mz</a> (const std::size_t qubitIdx, const std::string &amp;registerName) override</td></tr>
<tr class="memdesc:aa76554791ab3f3710de84ab86cacd45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure operation. Here we check what the current execution context is. If the context is sample, then we do nothing but store the measure qubit, which we then use to do full state sampling when flushAnySamplingTask() is called. If the context is sample-conditional, then we have a circuit that contains if (<code>mz(q)</code>) and we measure the qubit, collapse the state, and then store the sample qubit for final full state sampling. We also return the bit result. If no execution context, just measure, collapse, and return the bit.  <br /></td></tr>
<tr class="separator:aa76554791ab3f3710de84ab86cacd45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473e81e11432addde5f36d9cbee1c193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a473e81e11432addde5f36d9cbee1c193">measureSpinOp</a> (const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;op) override</td></tr>
<tr class="separator:a473e81e11432addde5f36d9cbee1c193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d7a5de124177e650af2dad00a5bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a588d7a5de124177e650af2dad00a5bd8">u2</a> (const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="memdesc:a588d7a5de124177e650af2dad00a5bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The X gate.  <br /></td></tr>
<tr class="separator:a588d7a5de124177e650af2dad00a5bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc57806dbb5b84a58de2b3d2682e7fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aabc57806dbb5b84a58de2b3d2682e7fb">u2</a> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:aabc57806dbb5b84a58de2b3d2682e7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The X gate.  <br /></td></tr>
<tr class="separator:aabc57806dbb5b84a58de2b3d2682e7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0cd0283fe2b84ba73b00778fc09382"><td class="memItemLeft" align="right" valign="top"><a id="a9d0cd0283fe2b84ba73b00778fc09382" name="a9d0cd0283fe2b84ba73b00778fc09382"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>u3</b> (const double theta, const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="separator:a9d0cd0283fe2b84ba73b00778fc09382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe3419977322f608b96c902bfc23720"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#abbe3419977322f608b96c902bfc23720">u3</a> (const double theta, const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:abbe3419977322f608b96c902bfc23720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce475a223e738a422853f54e455f3ba"><td class="memItemLeft" align="right" valign="top"><a id="abce475a223e738a422853f54e455f3ba" name="abce475a223e738a422853f54e455f3ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>phased_rx</b> (const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="separator:abce475a223e738a422853f54e455f3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf68d21cae760f7170cb8ded24d5356"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a9cf68d21cae760f7170cb8ded24d5356">phased_rx</a> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:a9cf68d21cae760f7170cb8ded24d5356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1c8e220759e335acbc18817dd42509"><td class="memItemLeft" align="right" valign="top"><a id="a1a1c8e220759e335acbc18817dd42509" name="a1a1c8e220759e335acbc18817dd42509"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (const std::size_t srcIdx, const std::size_t tgtIdx)</td></tr>
<tr class="memdesc:a1a1c8e220759e335acbc18817dd42509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the SWAP gate. <br /></td></tr>
<tr class="separator:a1a1c8e220759e335acbc18817dd42509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f79da489b573f47dd0a3d06de07967c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a1f79da489b573f47dd0a3d06de07967c">swap</a> (const std::vector&lt; std::size_t &gt; &amp;ctrlBits, const std::size_t srcIdx, const std::size_t tgtIdx)=0</td></tr>
<tr class="memdesc:a1f79da489b573f47dd0a3d06de07967c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a general multi-control swap gate.  <br /></td></tr>
<tr class="separator:a1f79da489b573f47dd0a3d06de07967c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classnvqir_1_1CircuitSimulator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classnvqir_1_1CircuitSimulator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a></td></tr>
<tr class="memitem:a47d22399823d9c78a8cf57173dc6b52a inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>CircuitSimulator</b> ()=default</td></tr>
<tr class="memdesc:a47d22399823d9c78a8cf57173dc6b52a inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor. <br /></td></tr>
<tr class="separator:a47d22399823d9c78a8cf57173dc6b52a inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac024267d75a23fb69d235b21a64153bf inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~CircuitSimulator</b> ()=default</td></tr>
<tr class="memdesc:ac024267d75a23fb69d235b21a64153bf inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor. <br /></td></tr>
<tr class="separator:ac024267d75a23fb69d235b21a64153bf inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9626a65f7f66486b0753641d0039540e inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>flushGateQueue</b> ()</td></tr>
<tr class="memdesc:a9626a65f7f66486b0753641d0039540e inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the current queue of gates, i.e. apply them to the state. <br /></td></tr>
<tr class="separator:a9626a65f7f66486b0753641d0039540e inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea494aac7ce1db35fa9f0badb624c00d inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>tearDownBeforeMPIFinalize</b> ()</td></tr>
<tr class="memdesc:aea494aac7ce1db35fa9f0badb624c00d inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an opportunity for any tear-down tasks before MPI Finalize is invoked. Here we leave this unimplemented, it is meant for subclasses. <br /></td></tr>
<tr class="separator:aea494aac7ce1db35fa9f0badb624c00d inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deadc9d6676b1ecf73232f36c819f80 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a2deadc9d6676b1ecf73232f36c819f80">createStateFromData</a> (const cudaq::state_data &amp;)=0</td></tr>
<tr class="memdesc:a2deadc9d6676b1ecf73232f36c819f80 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a mechanism for simulators to create and return a <code>SimulationState</code> instance from a user-specified data set.  <br /></td></tr>
<tr class="separator:a2deadc9d6676b1ecf73232f36c819f80 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae574715d2e8dc383622c1c59c7e7cf05 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#ae574715d2e8dc383622c1c59c7e7cf05">setNoiseModel</a> (<a class="el" href="classcudaq_1_1noise__model.html">cudaq::noise_model</a> &amp;noise)=0</td></tr>
<tr class="memdesc:ae574715d2e8dc383622c1c59c7e7cf05 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current noise model to consider when simulating the state. This should be overridden by simulation strategies that support noise modeling.  <br /></td></tr>
<tr class="separator:ae574715d2e8dc383622c1c59c7e7cf05 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc07efde90fa2b52209a9f4b3859babd inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setRandomSeed</b> (std::size_t seed)</td></tr>
<tr class="separator:abc07efde90fa2b52209a9f4b3859babd inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbf18a22d4b5698a0fc30069824ef50 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#adbbf18a22d4b5698a0fc30069824ef50">synchronize</a> ()</td></tr>
<tr class="memdesc:adbbf18a22d4b5698a0fc30069824ef50 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any flushing or synchronization to force that all previously applied gates have truly been applied by the underlying simulator.  <br /></td></tr>
<tr class="separator:adbbf18a22d4b5698a0fc30069824ef50 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf20fc4a8a18f1ea29472ec4198e9c6f inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>applyExpPauli</b> (double theta, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; std::size_t &gt; &amp;qubitIds, const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;op)</td></tr>
<tr class="memdesc:aaf20fc4a8a18f1ea29472ec4198e9c6f inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply exp(-i theta PauliTensorProd) to the underlying state. This must be provided by subclasses. <br /></td></tr>
<tr class="separator:aaf20fc4a8a18f1ea29472ec4198e9c6f inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e070ba9b076835b153eedf21dcd4505 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcudaq_1_1observe__result.html">cudaq::observe_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a9e070ba9b076835b153eedf21dcd4505">observe</a> (const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;term)=0</td></tr>
<tr class="memdesc:a9e070ba9b076835b153eedf21dcd4505 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the expected value of the given spin op with respect to the current state, &lt;psi | H | psi&gt;.  <br /></td></tr>
<tr class="separator:a9e070ba9b076835b153eedf21dcd4505 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2905039c70f46417b4a660bb3620f84 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#ad2905039c70f46417b4a660bb3620f84">allocateQubit</a> ()=0</td></tr>
<tr class="memdesc:ad2905039c70f46417b4a660bb3620f84 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a single qubit, return the qubit as a logical index.  <br /></td></tr>
<tr class="separator:ad2905039c70f46417b4a660bb3620f84 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02bb6efa6b958b6365c1591bb5e5660 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#af02bb6efa6b958b6365c1591bb5e5660">allocateQubits</a> (std::size_t count, const void *state=nullptr, cudaq::simulation_precision precision=cudaq::simulation_precision::fp32)=0</td></tr>
<tr class="memdesc:af02bb6efa6b958b6365c1591bb5e5660 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <code>count</code> qubits.  <br /></td></tr>
<tr class="separator:af02bb6efa6b958b6365c1591bb5e5660 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f1bec810fdfb1ed5af129f7ddb0835 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a27f1bec810fdfb1ed5af129f7ddb0835">allocateQubits</a> (std::size_t count, const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> *state)=0</td></tr>
<tr class="separator:a27f1bec810fdfb1ed5af129f7ddb0835 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7410d4474aec0fd02a06d6f39ac620 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#afb7410d4474aec0fd02a06d6f39ac620">deallocate</a> (const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:afb7410d4474aec0fd02a06d6f39ac620 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the qubit with give unique index.  <br /></td></tr>
<tr class="separator:afb7410d4474aec0fd02a06d6f39ac620 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69469a664a9b28d82f9e441d3af05414 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a69469a664a9b28d82f9e441d3af05414">deallocateQubits</a> (const std::vector&lt; std::size_t &gt; &amp;qubits)=0</td></tr>
<tr class="memdesc:a69469a664a9b28d82f9e441d3af05414 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate all the provided qubits.  <br /></td></tr>
<tr class="separator:a69469a664a9b28d82f9e441d3af05414 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d30f87fa79e77ed6cb601db01357d4 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#ad3d30f87fa79e77ed6cb601db01357d4">resetExecutionContext</a> ()=0</td></tr>
<tr class="memdesc:ad3d30f87fa79e77ed6cb601db01357d4 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the current execution context.  <br /></td></tr>
<tr class="separator:ad3d30f87fa79e77ed6cb601db01357d4 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ba278d5a49474f22376831ef2e0d4d inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a29ba278d5a49474f22376831ef2e0d4d">setExecutionContext</a> (<a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *context)=0</td></tr>
<tr class="memdesc:a29ba278d5a49474f22376831ef2e0d4d inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the execution context.  <br /></td></tr>
<tr class="separator:a29ba278d5a49474f22376831ef2e0d4d inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc248c708f5c6c3e524bd461236a403b inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#afc248c708f5c6c3e524bd461236a403b">getExecutionContext</a> ()=0</td></tr>
<tr class="memdesc:afc248c708f5c6c3e524bd461236a403b inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current execution context.  <br /></td></tr>
<tr class="separator:afc248c708f5c6c3e524bd461236a403b inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dafa8b33cc39e9dcd6268f3331225c8 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isStateVectorSimulator</b> () const</td></tr>
<tr class="memdesc:a7dafa8b33cc39e9dcd6268f3331225c8 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not this is a state vector simulator. <br /></td></tr>
<tr class="separator:a7dafa8b33cc39e9dcd6268f3331225c8 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ddfc0b4789977d7ebcdcbfb862a814 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a35ddfc0b4789977d7ebcdcbfb862a814">applyCustomOperation</a> (const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;matrix, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; std::size_t &gt; &amp;targets, const std::string_view customUnitaryName=&quot;&quot;)=0</td></tr>
<tr class="memdesc:a35ddfc0b4789977d7ebcdcbfb862a814 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a custom operation described by a matrix of data represented as 1-D vector of elements in row-major order, as well as the the control qubit and target indices.  <br /></td></tr>
<tr class="separator:a35ddfc0b4789977d7ebcdcbfb862a814 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d7a5de124177e650af2dad00a5bd8 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a588d7a5de124177e650af2dad00a5bd8">u2</a> (const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="memdesc:a588d7a5de124177e650af2dad00a5bd8 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The X gate.  <br /></td></tr>
<tr class="separator:a588d7a5de124177e650af2dad00a5bd8 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc57806dbb5b84a58de2b3d2682e7fb inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#aabc57806dbb5b84a58de2b3d2682e7fb">u2</a> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:aabc57806dbb5b84a58de2b3d2682e7fb inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce475a223e738a422853f54e455f3ba inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>phased_rx</b> (const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="separator:abce475a223e738a422853f54e455f3ba inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf68d21cae760f7170cb8ded24d5356 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>phased_rx</b> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:a9cf68d21cae760f7170cb8ded24d5356 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0cd0283fe2b84ba73b00778fc09382 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>u3</b> (const double theta, const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="separator:a9d0cd0283fe2b84ba73b00778fc09382 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe3419977322f608b96c902bfc23720 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>u3</b> (const double theta, const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:abbe3419977322f608b96c902bfc23720 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1c8e220759e335acbc18817dd42509 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (const std::size_t srcIdx, const std::size_t tgtIdx)</td></tr>
<tr class="memdesc:a1a1c8e220759e335acbc18817dd42509 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the SWAP gate. <br /></td></tr>
<tr class="separator:a1a1c8e220759e335acbc18817dd42509 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f79da489b573f47dd0a3d06de07967c inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a1f79da489b573f47dd0a3d06de07967c">swap</a> (const std::vector&lt; std::size_t &gt; &amp;ctrlBits, const std::size_t srcIdx, const std::size_t tgtIdx)=0</td></tr>
<tr class="memdesc:a1f79da489b573f47dd0a3d06de07967c inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a general multi-control swap gate.  <br /></td></tr>
<tr class="separator:a1f79da489b573f47dd0a3d06de07967c inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f91a840b5d37a74dafe0b7f3fc16315 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a4f91a840b5d37a74dafe0b7f3fc16315">mz</a> (const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:a4f91a840b5d37a74dafe0b7f3fc16315 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the qubit with given index.  <br /></td></tr>
<tr class="separator:a4f91a840b5d37a74dafe0b7f3fc16315 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e00d245e8f51b9ebc7ec48dca2db52e inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a9e00d245e8f51b9ebc7ec48dca2db52e">mz</a> (const std::size_t qubitIdx, const std::string &amp;registerName)=0</td></tr>
<tr class="memdesc:a9e00d245e8f51b9ebc7ec48dca2db52e inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure operation. Here we check what the current execution context is. If the context is sample, then we do nothing but store the measure qubit, which we then use to do full state sampling when flushAnySamplingTask() is called. If the context is sample-conditional, then we have a circuit that contains if (<code>mz(q)</code>) and we measure the qubit, collapse the state, and then store the sample qubit for final full state sampling. We also return the bit result. If no execution context, just measure, collapse, and return the bit.  <br /></td></tr>
<tr class="separator:a9e00d245e8f51b9ebc7ec48dca2db52e inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b46c0caa94ec5b83365e5404b4895a6 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>measureSpinOp</b> (const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;op)=0</td></tr>
<tr class="separator:a5b46c0caa94ec5b83365e5404b4895a6 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f47166da5758fbf736f6296ade3b67 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a70f47166da5758fbf736f6296ade3b67">resetQubit</a> (const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:a70f47166da5758fbf736f6296ade3b67 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the qubit to the |0&gt; state.  <br /></td></tr>
<tr class="separator:a70f47166da5758fbf736f6296ade3b67 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391aa9fe5634e67f340ef7bce0294bcb inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structcudaq_1_1ExecutionResult.html">cudaq::ExecutionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a391aa9fe5634e67f340ef7bce0294bcb">sample</a> (const std::vector&lt; std::size_t &gt; &amp;qubitIdxs, const int shots)=0</td></tr>
<tr class="memdesc:a391aa9fe5634e67f340ef7bce0294bcb inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the current multi-qubit state on the given qubit indices over a certain number of shots.  <br /></td></tr>
<tr class="separator:a391aa9fe5634e67f340ef7bce0294bcb inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e55127239da3d7bd57d0c623bd287c3 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const =0</td></tr>
<tr class="memdesc:a5e55127239da3d7bd57d0c623bd287c3 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a>. <br /></td></tr>
<tr class="separator:a5e55127239da3d7bd57d0c623bd287c3 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fa404ffe5cac5ee0afef9cb3129838 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvqir_1_1CircuitSimulator.html">CircuitSimulator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a42fa404ffe5cac5ee0afef9cb3129838">clone</a> ()=0</td></tr>
<tr class="memdesc:a42fa404ffe5cac5ee0afef9cb3129838 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a thread_local pointer to this <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a>.  <br /></td></tr>
<tr class="separator:a42fa404ffe5cac5ee0afef9cb3129838 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4132e9eabbc6826c4728cfdaa1aca6 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a5e4132e9eabbc6826c4728cfdaa1aca6">isSinglePrecision</a> () const =0</td></tr>
<tr class="memdesc:a5e4132e9eabbc6826c4728cfdaa1aca6 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the (preferred) precision of the simulator.  <br /></td></tr>
<tr class="separator:a5e4132e9eabbc6826c4728cfdaa1aca6 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba71c9c4600be22d2950c918e65c5c05 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDoublePrecision</b> () const</td></tr>
<tr class="separator:aba71c9c4600be22d2950c918e65c5c05 inherit pub_methods_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a89a6671737a280ff9a0fe89f77246410"><td class="memItemLeft" align="right" valign="top"><a id="a89a6671737a280ff9a0fe89f77246410" name="a89a6671737a280ff9a0fe89f77246410"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getCircuitName</b> () const</td></tr>
<tr class="memdesc:a89a6671737a280ff9a0fe89f77246410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current circuit being executed. <br /></td></tr>
<tr class="separator:a89a6671737a280ff9a0fe89f77246410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81671f15a1e60490fd1f4ec8ff52e9f3"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a81671f15a1e60490fd1f4ec8ff52e9f3">calculateStateDim</a> (const std::size_t numQubits)</td></tr>
<tr class="memdesc:a81671f15a1e60490fd1f4ec8ff52e9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current multi-qubit state dimension.  <br /></td></tr>
<tr class="separator:a81671f15a1e60490fd1f4ec8ff52e9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c490a33b47daab08e7cf0ee5cb21189"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a8c490a33b47daab08e7cf0ee5cb21189">addQubitToState</a> ()=0</td></tr>
<tr class="memdesc:a8c490a33b47daab08e7cf0ee5cb21189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new qubit to the state representation. This is subclass specific.  <br /></td></tr>
<tr class="separator:a8c490a33b47daab08e7cf0ee5cb21189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aabf5085b5c769e4c275afd43aca82c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a9aabf5085b5c769e4c275afd43aca82c">deallocateStateImpl</a> ()=0</td></tr>
<tr class="memdesc:a9aabf5085b5c769e4c275afd43aca82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass specific part of <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a8efd3682cd8583d5505e37fc832109cd" title="Reset the qubit state back to dim = 0.">deallocateState()</a>. It will be invoked by <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a8efd3682cd8583d5505e37fc832109cd" title="Reset the qubit state back to dim = 0.">deallocateState()</a>  <br /></td></tr>
<tr class="separator:a9aabf5085b5c769e4c275afd43aca82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efd3682cd8583d5505e37fc832109cd"><td class="memItemLeft" align="right" valign="top"><a id="a8efd3682cd8583d5505e37fc832109cd" name="a8efd3682cd8583d5505e37fc832109cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocateState</b> ()</td></tr>
<tr class="memdesc:a8efd3682cd8583d5505e37fc832109cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the qubit state back to dim = 0. <br /></td></tr>
<tr class="separator:a8efd3682cd8583d5505e37fc832109cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e5497286e6eefcaded89111c61fcc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#afe1e5497286e6eefcaded89111c61fcc">measureQubit</a> (const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:afe1e5497286e6eefcaded89111c61fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the actual mechanics of measuring a qubit, left as a task for concrete subtypes.  <br /></td></tr>
<tr class="separator:afe1e5497286e6eefcaded89111c61fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271ed4d7594290efd16cdfe4028e3903"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a271ed4d7594290efd16cdfe4028e3903">canHandleObserve</a> ()</td></tr>
<tr class="memdesc:a271ed4d7594290efd16cdfe4028e3903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a> can handle &lt;psi | H | psi&gt; instead of NVQIR applying measure basis quantum gates to change to the Z basis and sample.  <br /></td></tr>
<tr class="separator:a271ed4d7594290efd16cdfe4028e3903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f357a77723431495beb4a99cd73060"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ac5f357a77723431495beb4a99cd73060">getSimulationState</a> ()</td></tr>
<tr class="memdesc:ac5f357a77723431495beb4a99cd73060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the internal state representation. This is meant for subtypes to override.  <br /></td></tr>
<tr class="separator:ac5f357a77723431495beb4a99cd73060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6797b9b19c18533f5bbef02051ee7a"><td class="memItemLeft" align="right" valign="top"><a id="adc6797b9b19c18533f5bbef02051ee7a" name="adc6797b9b19c18533f5bbef02051ee7a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>handleBasicSampling</b> (const std::size_t qubitIdx, const std::string &amp;regName)</td></tr>
<tr class="memdesc:adc6797b9b19c18533f5bbef02051ee7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle basic sampling tasks by storing the qubit index for processing in resetExecutionContext. Return true to indicate this is sampling and to exit early. False otherwise. <br /></td></tr>
<tr class="separator:adc6797b9b19c18533f5bbef02051ee7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7333fec577427472b221c795aa2dd9c2"><td class="memItemLeft" align="right" valign="top"><a id="a7333fec577427472b221c795aa2dd9c2" name="a7333fec577427472b221c795aa2dd9c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>handleSamplingWithConditionals</b> (const std::size_t qubitIdx, const std::string bitResult, const std::string &amp;registerName)</td></tr>
<tr class="memdesc:a7333fec577427472b221c795aa2dd9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function handles sampling in the presence of conditional statements on qubit measurement results. Specifically, it will keep track of a classical register for all measures encountered in the program and store mid-circuit measures in the corresponding register. <br /></td></tr>
<tr class="separator:a7333fec577427472b221c795aa2dd9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d34b67e57afb0c32641c7357a6dd8bf"><td class="memItemLeft" align="right" valign="top"><a id="a2d34b67e57afb0c32641c7357a6dd8bf" name="a2d34b67e57afb0c32641c7357a6dd8bf"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>gateToString</b> (const std::string_view gateName, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; ScalarType &gt; &amp;parameters, const std::vector&lt; std::size_t &gt; &amp;targets)</td></tr>
<tr class="memdesc:a2d34b67e57afb0c32641c7357a6dd8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns a string-view of the current quantum instruction, intended for logging purposes. <br /></td></tr>
<tr class="separator:a2d34b67e57afb0c32641c7357a6dd8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32c98bdcb68fe86f306d25e97e29acd"><td class="memItemLeft" align="right" valign="top"><a id="ae32c98bdcb68fe86f306d25e97e29acd" name="ae32c98bdcb68fe86f306d25e97e29acd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isInBatchMode</b> ()</td></tr>
<tr class="memdesc:ae32c98bdcb68fe86f306d25e97e29acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the current execution is in batch mode. <br /></td></tr>
<tr class="separator:ae32c98bdcb68fe86f306d25e97e29acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056a874c225fc8533acee613da3833d5"><td class="memItemLeft" align="right" valign="top"><a id="a056a874c225fc8533acee613da3833d5" name="a056a874c225fc8533acee613da3833d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isLastBatch</b> ()</td></tr>
<tr class="memdesc:a056a874c225fc8533acee613da3833d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the current execution is the last execution of batch mode. <br /></td></tr>
<tr class="separator:a056a874c225fc8533acee613da3833d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f85f0666206207d3a59bec22d5a5d"><td class="memItemLeft" align="right" valign="top"><a id="aa50f85f0666206207d3a59bec22d5a5d" name="aa50f85f0666206207d3a59bec22d5a5d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addQubitsToState</b> (std::size_t count, const void *state=nullptr)</td></tr>
<tr class="memdesc:aa50f85f0666206207d3a59bec22d5a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given number of qubits to the state. <br /></td></tr>
<tr class="separator:aa50f85f0666206207d3a59bec22d5a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917c914f0596a4d676b9f46b3bde0228"><td class="memItemLeft" align="right" valign="top"><a id="a917c914f0596a4d676b9f46b3bde0228" name="a917c914f0596a4d676b9f46b3bde0228"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addQubitsToState</b> (const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &amp;state)</td></tr>
<tr class="memdesc:a917c914f0596a4d676b9f46b3bde0228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add (appending) the given simulation state to the current simulator state. <br /></td></tr>
<tr class="separator:a917c914f0596a4d676b9f46b3bde0228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5d319e6ae9baa3d7b36c27e7b18b22"><td class="memItemLeft" align="right" valign="top"><a id="a5c5d319e6ae9baa3d7b36c27e7b18b22" name="a5c5d319e6ae9baa3d7b36c27e7b18b22"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flushAnySamplingTasks</b> (bool force=false)</td></tr>
<tr class="memdesc:a5c5d319e6ae9baa3d7b36c27e7b18b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a sampling task with the current set of sample qubits. <br /></td></tr>
<tr class="separator:a5c5d319e6ae9baa3d7b36c27e7b18b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bc16fc13f2c83a68bb7dd41ddea4dd"><td class="memItemLeft" align="right" valign="top"><a id="a98bc16fc13f2c83a68bb7dd41ddea4dd" name="a98bc16fc13f2c83a68bb7dd41ddea4dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>enqueueGate</b> (const std::string <a class="el" href="classnvqir_1_1CircuitSimulator.html#a5e55127239da3d7bd57d0c623bd287c3">name</a>, const std::vector&lt; std::complex&lt; ScalarType &gt; &gt; &amp;matrix, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; std::size_t &gt; &amp;targets, const std::vector&lt; ScalarType &gt; &amp;params)</td></tr>
<tr class="memdesc:a98bc16fc13f2c83a68bb7dd41ddea4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new gate application task to the queue. <br /></td></tr>
<tr class="separator:a98bc16fc13f2c83a68bb7dd41ddea4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b290309273ea131060a5701121ac403"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a5b290309273ea131060a5701121ac403">applyGate</a> (const <a class="el" href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html">GateApplicationTask</a> &amp;task)=0</td></tr>
<tr class="memdesc:a5b290309273ea131060a5701121ac403"><td class="mdescLeft">&#160;</td><td class="mdescRight">This pure virtual method is meant for subtypes to implement, and its goal is to apply the gate described by the <a class="el" href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html" title="A GateApplicationTask consists of a matrix describing the quantum operation, a set of possible contro...">GateApplicationTask</a> to the subtype-specific state data representation.  <br /></td></tr>
<tr class="separator:a5b290309273ea131060a5701121ac403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ef6f4e32b274fab618e8390b5c6d53"><td class="memItemLeft" align="right" valign="top"><a id="ad1ef6f4e32b274fab618e8390b5c6d53" name="ad1ef6f4e32b274fab618e8390b5c6d53"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>applyNoiseChannel</b> (const std::string_view gateName, const std::vector&lt; std::size_t &gt; &amp;qubits)</td></tr>
<tr class="memdesc:ad1ef6f4e32b274fab618e8390b5c6d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a base-class method that can be invoked after every gate application and will apply any noise channels after the gate invocation based on a user-provided noise model. Unimplemented on the base class, sub-types can implement noise modeling. <br /></td></tr>
<tr class="separator:ad1ef6f4e32b274fab618e8390b5c6d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c8390993b4f5269cce9eeb00f6101c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a18c8390993b4f5269cce9eeb00f6101c">flushGateQueueImpl</a> () override</td></tr>
<tr class="memdesc:a18c8390993b4f5269cce9eeb00f6101c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the gate queue, run all queued gate application tasks.  <br /></td></tr>
<tr class="separator:a18c8390993b4f5269cce9eeb00f6101c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aebceb7ce5cfc42796f108552c2d38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a23aebceb7ce5cfc42796f108552c2d38">setToZeroState</a> ()=0</td></tr>
<tr class="memdesc:a23aebceb7ce5cfc42796f108552c2d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current state to the |0&gt; state, retaining the current number of qubits.  <br /></td></tr>
<tr class="separator:a23aebceb7ce5cfc42796f108552c2d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada5f04c26a88406a012aba267994fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aada5f04c26a88406a012aba267994fc1">shouldObserveFromSampling</a> (bool defaultConfig=true)</td></tr>
<tr class="memdesc:aada5f04c26a88406a012aba267994fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if expectation values should be computed from sampling + parity of bit strings. Default is to enable observe from sampling, i.e., simulating the change-of-basis circuit for each term.  <br /></td></tr>
<tr class="separator:aada5f04c26a88406a012aba267994fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9c8029c1c1f4eea5614dc6363a07b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#acd9c8029c1c1f4eea5614dc6363a07b2">isSinglePrecision</a> () const override</td></tr>
<tr class="memdesc:acd9c8029c1c1f4eea5614dc6363a07b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the (preferred) precision of the simulator.  <br /></td></tr>
<tr class="separator:acd9c8029c1c1f4eea5614dc6363a07b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07719ae906b797a2dc4a53247c3f0074"><td class="memItemLeft" align="right" valign="top">virtual QubitOrdering&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a07719ae906b797a2dc4a53247c3f0074">getQubitOrdering</a> () const</td></tr>
<tr class="memdesc:a07719ae906b797a2dc4a53247c3f0074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this simulator's qubit ordering.  <br /></td></tr>
<tr class="separator:a07719ae906b797a2dc4a53247c3f0074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af435eda7b0b1c3c80145ccfbae5e06af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#af435eda7b0b1c3c80145ccfbae5e06af">flushGateQueueImpl</a> ()=0</td></tr>
<tr class="memdesc:af435eda7b0b1c3c80145ccfbae5e06af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the current queue of gates, i.e. apply them to the state. Internal and meant for subclasses to implement.  <br /></td></tr>
<tr class="separator:af435eda7b0b1c3c80145ccfbae5e06af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6554d5d33ae9288c09a600cbb098c730"><td class="memItemLeft" align="right" valign="top"><a id="a6554d5d33ae9288c09a600cbb098c730" name="a6554d5d33ae9288c09a600cbb098c730"></a>
<a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>executionContext</b> = nullptr</td></tr>
<tr class="memdesc:a6554d5d33ae9288c09a600cbb098c730"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current Execution Context (typically this is null, sampling, or spin_op observation. <br /></td></tr>
<tr class="separator:a6554d5d33ae9288c09a600cbb098c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1227aa8226bba22c0103e29e589524ac"><td class="memItemLeft" align="right" valign="top"><a id="a1227aa8226bba22c0103e29e589524ac" name="a1227aa8226bba22c0103e29e589524ac"></a>
<a class="el" href="classcudaq_1_1QuditIdTracker.html">cudaq::QuditIdTracker</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tracker</b></td></tr>
<tr class="memdesc:a1227aa8226bba22c0103e29e589524ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tracker for qubit allocation. <br /></td></tr>
<tr class="separator:a1227aa8226bba22c0103e29e589524ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdd9f24a3375c94a8fa1bac84be1dca"><td class="memItemLeft" align="right" valign="top"><a id="a9fdd9f24a3375c94a8fa1bac84be1dca" name="a9fdd9f24a3375c94a8fa1bac84be1dca"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nQubitsAllocated</b> = 0</td></tr>
<tr class="memdesc:a9fdd9f24a3375c94a8fa1bac84be1dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of qubits that have been allocated. <br /></td></tr>
<tr class="separator:a9fdd9f24a3375c94a8fa1bac84be1dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e6dd81439e6d293a414e09066389ca"><td class="memItemLeft" align="right" valign="top"><a id="a81e6dd81439e6d293a414e09066389ca" name="a81e6dd81439e6d293a414e09066389ca"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>stateDimension</b> = 0</td></tr>
<tr class="memdesc:a81e6dd81439e6d293a414e09066389ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of the multi-qubit state. <br /></td></tr>
<tr class="separator:a81e6dd81439e6d293a414e09066389ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0a3ddceeaa4e4c8e6653d358bd3555"><td class="memItemLeft" align="right" valign="top"><a id="a8e0a3ddceeaa4e4c8e6653d358bd3555" name="a8e0a3ddceeaa4e4c8e6653d358bd3555"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>previousStateDimension</b> = 0</td></tr>
<tr class="memdesc:a8e0a3ddceeaa4e4c8e6653d358bd3555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep track of the previous state dimension as we grow the state. <br /></td></tr>
<tr class="separator:a8e0a3ddceeaa4e4c8e6653d358bd3555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20523555b57f1f8d724d7c59f8632499"><td class="memItemLeft" align="right" valign="top"><a id="a20523555b57f1f8d724d7c59f8632499" name="a20523555b57f1f8d724d7c59f8632499"></a>
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sampleQubits</b></td></tr>
<tr class="memdesc:a20523555b57f1f8d724d7c59f8632499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector containing qubit ids that are to be sampled. <br /></td></tr>
<tr class="separator:a20523555b57f1f8d724d7c59f8632499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267ded4dbc19bbc1285e0a72d99b5265"><td class="memItemLeft" align="right" valign="top"><a id="a267ded4dbc19bbc1285e0a72d99b5265" name="a267ded4dbc19bbc1285e0a72d99b5265"></a>
std::unordered_map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>midCircuitSampleResults</b></td></tr>
<tr class="memdesc:a267ded4dbc19bbc1285e0a72d99b5265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map of register name to observed bit results for mid-circuit sampling. <br /></td></tr>
<tr class="separator:a267ded4dbc19bbc1285e0a72d99b5265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f54c8b92f4f3869e7cc0a9c6b4de7cd"><td class="memItemLeft" align="right" valign="top"><a id="a2f54c8b92f4f3869e7cc0a9c6b4de7cd" name="a2f54c8b92f4f3869e7cc0a9c6b4de7cd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>lastMidCircuitRegisterName</b> = &quot;&quot;</td></tr>
<tr class="memdesc:a2f54c8b92f4f3869e7cc0a9c6b4de7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the last observed register name, this will help us know if we are writing to a classical bit vector. <br /></td></tr>
<tr class="separator:a2f54c8b92f4f3869e7cc0a9c6b4de7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c1cc587577915061db42e9c52eae53"><td class="memItemLeft" align="right" valign="top"><a id="a88c1cc587577915061db42e9c52eae53" name="a88c1cc587577915061db42e9c52eae53"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vectorRegisters</b></td></tr>
<tr class="memdesc:a88c1cc587577915061db42e9c52eae53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector storing register names that are bit vectors. <br /></td></tr>
<tr class="separator:a88c1cc587577915061db42e9c52eae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088df7540477e0dff64351d567b49af8"><td class="memItemLeft" align="right" valign="top"><a id="a088df7540477e0dff64351d567b49af8" name="a088df7540477e0dff64351d567b49af8"></a>
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>deferredDeallocation</b></td></tr>
<tr class="memdesc:a088df7540477e0dff64351d567b49af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Under certain execution contexts, we'll deallocate before we are actually done with the execution task, this vector keeps track of qubit ids that are to be deallocated at a later time. <br /></td></tr>
<tr class="separator:a088df7540477e0dff64351d567b49af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc10168abd9ee0bf32829ec56e6711"><td class="memItemLeft" align="right" valign="top"><a id="aecfc10168abd9ee0bf32829ec56e6711" name="aecfc10168abd9ee0bf32829ec56e6711"></a>
std::unordered_map&lt; std::string, std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>registerNameToMeasuredQubit</b></td></tr>
<tr class="memdesc:aecfc10168abd9ee0bf32829ec56e6711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map bit register names to the qubits that make it up. <br /></td></tr>
<tr class="separator:aecfc10168abd9ee0bf32829ec56e6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4eaf30117620b092f1c17af71d21d53"><td class="memItemLeft" align="right" valign="top"><a id="ae4eaf30117620b092f1c17af71d21d53" name="ae4eaf30117620b092f1c17af71d21d53"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>batchModeCurrentNumQubits</b> = 0</td></tr>
<tr class="memdesc:ae4eaf30117620b092f1c17af71d21d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep track of the current number of qubits in batch mode. <br /></td></tr>
<tr class="separator:ae4eaf30117620b092f1c17af71d21d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b052ba4fe01deb76a413c4072e920e6"><td class="memItemLeft" align="right" valign="top"><a id="a2b052ba4fe01deb76a413c4072e920e6" name="a2b052ba4fe01deb76a413c4072e920e6"></a>
std::queue&lt; <a class="el" href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html">GateApplicationTask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gateQueue</b></td></tr>
<tr class="memdesc:a2b052ba4fe01deb76a413c4072e920e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current queue of operations to execute. <br /></td></tr>
<tr class="separator:a2b052ba4fe01deb76a413c4072e920e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classnvqir_1_1CircuitSimulator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classnvqir_1_1CircuitSimulator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a></td></tr>
<tr class="memitem:a62034e4bcf808c0756a1eb2b614bc408 inherit pro_attribs_classnvqir_1_1CircuitSimulator"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structnvqir_1_1SummaryData.html">SummaryData</a>&#160;</td><td class="memItemRight" valign="bottom"><b>summaryData</b></td></tr>
<tr class="memdesc:a62034e4bcf808c0756a1eb2b614bc408 inherit pro_attribs_classnvqir_1_1CircuitSimulator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics collected over the life of the simulator. <br /></td></tr>
<tr class="separator:a62034e4bcf808c0756a1eb2b614bc408 inherit pro_attribs_classnvqir_1_1CircuitSimulator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a8b16545255b68bf4c350a4e4a3a9d52a"><td class="memItemLeft" align="right" valign="top">static constexpr const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a8b16545255b68bf4c350a4e4a3a9d52a">observeSamplingEnvVar</a> []</td></tr>
<tr class="memdesc:a8b16545255b68bf4c350a4e4a3a9d52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Environment variable name that allows a programmer to specify how expectation values should be computed. This defaults to true.  <br /></td></tr>
<tr class="separator:a8b16545255b68bf4c350a4e4a3a9d52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ScalarType&gt;<br />
class nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</div><p>The <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html" title="The CircuitSimulatorBase is the type that is meant to be subclassed for new simulation strategies....">CircuitSimulatorBase</a> is the type that is meant to be subclassed for new simulation strategies. The separation of <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a> from <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html" title="The CircuitSimulatorBase is the type that is meant to be subclassed for new simulation strategies....">CircuitSimulatorBase</a> allows simulation sub-types to specify the floating point precision for the simulation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a81671f15a1e60490fd1f4ec8ff52e9f3" name="a81671f15a1e60490fd1f4ec8ff52e9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81671f15a1e60490fd1f4ec8ff52e9f3">&#9670;&#160;</a></span>calculateStateDim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::calculateStateDim </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>numQubits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current multi-qubit state dimension. </p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a3e7d33fd949819d25fe25672bcaffdd3">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a8c490a33b47daab08e7cf0ee5cb21189" name="a8c490a33b47daab08e7cf0ee5cb21189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c490a33b47daab08e7cf0ee5cb21189">&#9670;&#160;</a></span>addQubitToState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::addQubitToState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new qubit to the state representation. This is subclass specific. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#ae1341bb7c86549546e2ad4df1972a206">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a9aabf5085b5c769e4c275afd43aca82c" name="a9aabf5085b5c769e4c275afd43aca82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aabf5085b5c769e4c275afd43aca82c">&#9670;&#160;</a></span>deallocateStateImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::deallocateStateImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subclass specific part of <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a8efd3682cd8583d5505e37fc832109cd" title="Reset the qubit state back to dim = 0.">deallocateState()</a>. It will be invoked by <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a8efd3682cd8583d5505e37fc832109cd" title="Reset the qubit state back to dim = 0.">deallocateState()</a> </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a6685e9f1182ef46b23a74e51e4e82d89">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="afe1e5497286e6eefcaded89111c61fcc" name="afe1e5497286e6eefcaded89111c61fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1e5497286e6eefcaded89111c61fcc">&#9670;&#160;</a></span>measureQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::measureQubit </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the actual mechanics of measuring a qubit, left as a task for concrete subtypes. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#aca1dd508f4fe41c3561b6b2bc991657e">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a271ed4d7594290efd16cdfe4028e3903" name="a271ed4d7594290efd16cdfe4028e3903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271ed4d7594290efd16cdfe4028e3903">&#9670;&#160;</a></span>canHandleObserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::canHandleObserve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a> can handle &lt;psi | H | psi&gt; instead of NVQIR applying measure basis quantum gates to change to the Z basis and sample. </p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a28fc6f66b5bd8a2fd015a1316c1e47d4">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="ac5f357a77723431495beb4a99cd73060" name="ac5f357a77723431495beb4a99cd73060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f357a77723431495beb4a99cd73060">&#9670;&#160;</a></span>getSimulationState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt; <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::getSimulationState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the internal state representation. This is meant for subtypes to override. </p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#aaf15d2e3054e227e732a8062a3ec5e7e">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a5b290309273ea131060a5701121ac403" name="a5b290309273ea131060a5701121ac403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b290309273ea131060a5701121ac403">&#9670;&#160;</a></span>applyGate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::applyGate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html">GateApplicationTask</a> &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This pure virtual method is meant for subtypes to implement, and its goal is to apply the gate described by the <a class="el" href="structnvqir_1_1CircuitSimulatorBase_1_1GateApplicationTask.html" title="A GateApplicationTask consists of a matrix describing the quantum operation, a set of possible contro...">GateApplicationTask</a> to the subtype-specific state data representation. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#ab4c850b358e33f7a113412e4c9edc38e">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a18c8390993b4f5269cce9eeb00f6101c" name="a18c8390993b4f5269cce9eeb00f6101c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c8390993b4f5269cce9eeb00f6101c">&#9670;&#160;</a></span>flushGateQueueImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::flushGateQueueImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the gate queue, run all queued gate application tasks. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#af435eda7b0b1c3c80145ccfbae5e06af">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a23aebceb7ce5cfc42796f108552c2d38" name="a23aebceb7ce5cfc42796f108552c2d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23aebceb7ce5cfc42796f108552c2d38">&#9670;&#160;</a></span>setToZeroState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::setToZeroState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current state to the |0&gt; state, retaining the current number of qubits. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a9e29392e64b8c0b54ae73ed4cff41fac">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="aada5f04c26a88406a012aba267994fc1" name="aada5f04c26a88406a012aba267994fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada5f04c26a88406a012aba267994fc1">&#9670;&#160;</a></span>shouldObserveFromSampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::shouldObserveFromSampling </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultConfig</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if expectation values should be computed from sampling + parity of bit strings. Default is to enable observe from sampling, i.e., simulating the change-of-basis circuit for each term. </p>
<p>The environment variable "CUDAQ_OBSERVE_FROM_SAMPLING" can be used to turn on or off this setting. </p>

</div>
</div>
<a id="acd9c8029c1c1f4eea5614dc6363a07b2" name="acd9c8029c1c1f4eea5614dc6363a07b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9c8029c1c1f4eea5614dc6363a07b2">&#9670;&#160;</a></span>isSinglePrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::isSinglePrecision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the (preferred) precision of the simulator. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a5e4132e9eabbc6826c4728cfdaa1aca6">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a07719ae906b797a2dc4a53247c3f0074" name="a07719ae906b797a2dc4a53247c3f0074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07719ae906b797a2dc4a53247c3f0074">&#9670;&#160;</a></span>getQubitOrdering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual QubitOrdering <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::getQubitOrdering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this simulator's qubit ordering. </p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#acd7b35eaa9da15dea0a8059530f5f134">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a3cc00ca0015d1a941ee5974327f47826" name="a3cc00ca0015d1a941ee5974327f47826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc00ca0015d1a941ee5974327f47826">&#9670;&#160;</a></span>createStateFromData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt; <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::createStateFromData </td>
          <td>(</td>
          <td class="paramtype">const cudaq::state_data &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a simulation-specific SimulationState instance from a user-provided data set. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a2deadc9d6676b1ecf73232f36c819f80">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="ae95ee18d416e23546aa01ef4d00722d5" name="ae95ee18d416e23546aa01ef4d00722d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95ee18d416e23546aa01ef4d00722d5">&#9670;&#160;</a></span>setNoiseModel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::setNoiseModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudaq_1_1noise__model.html">cudaq::noise_model</a> &amp;&#160;</td>
          <td class="paramname"><em>noise</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current noise model to consider when simulating the state. This should be overridden by simulation strategies that support noise modeling. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#ae574715d2e8dc383622c1c59c7e7cf05">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="aa52476e6ee21a3921dd6046ab4d3678e" name="aa52476e6ee21a3921dd6046ab4d3678e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52476e6ee21a3921dd6046ab4d3678e">&#9670;&#160;</a></span>observe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudaq_1_1observe__result.html">cudaq::observe_result</a> <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::observe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the expected value of the given spin op with respect to the current state, &lt;psi | H | psi&gt;. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a9e070ba9b076835b153eedf21dcd4505">nvqir::CircuitSimulator</a>.</p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#ae7b6971782f7d0d9d619803488f7bed6">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a985f3ea7ac944dba1bc7097ca3dc865b" name="a985f3ea7ac944dba1bc7097ca3dc865b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985f3ea7ac944dba1bc7097ca3dc865b">&#9670;&#160;</a></span>allocateQubit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::allocateQubit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a single qubit, return the qubit as a logical index. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#ad2905039c70f46417b4a660bb3620f84">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="ac752abf42c181cec2c4171ef5258912f" name="ac752abf42c181cec2c4171ef5258912f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac752abf42c181cec2c4171ef5258912f">&#9670;&#160;</a></span>allocateQubits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::allocateQubits </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>state</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaq::simulation_precision&#160;</td>
          <td class="paramname"><em>precision</em> = <code>cudaq::simulation_precision::fp32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <code>count</code> qubits. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#af02bb6efa6b958b6365c1591bb5e5660">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a0f327c013941fab7971299990658f9d9" name="a0f327c013941fab7971299990658f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f327c013941fab7971299990658f9d9">&#9670;&#160;</a></span>allocateQubits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::allocateQubits </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <code>count</code> qubits in a specific state. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a54fd3292dbbbfefb2b7ed9253fd55a05" name="a54fd3292dbbbfefb2b7ed9253fd55a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fd3292dbbbfefb2b7ed9253fd55a05">&#9670;&#160;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the qubit with give index. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#afb7410d4474aec0fd02a06d6f39ac620">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="ae21b6d1a25fe767fc492fc700323d0c5" name="ae21b6d1a25fe767fc492fc700323d0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21b6d1a25fe767fc492fc700323d0c5">&#9670;&#160;</a></span>deallocateQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::deallocateQubits </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>qubits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate all requested qubits. If the number of qubits is equal to the number of allocated qubits, then clear the entire state at once. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a69469a664a9b28d82f9e441d3af05414">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a3c8c85f8f92fcc5a6bdf8c6ba73a4339" name="a3c8c85f8f92fcc5a6bdf8c6ba73a4339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8c85f8f92fcc5a6bdf8c6ba73a4339">&#9670;&#160;</a></span>resetExecutionContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::resetExecutionContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the current execution context. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#ad3d30f87fa79e77ed6cb601db01357d4">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="aed5e6f033833c8f5145f91c3ec164634" name="aed5e6f033833c8f5145f91c3ec164634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5e6f033833c8f5145f91c3ec164634">&#9670;&#160;</a></span>setExecutionContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::setExecutionContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the execution context. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a29ba278d5a49474f22376831ef2e0d4d">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a00b7d9f193338ffc2c5a30fa5e877d8d" name="a00b7d9f193338ffc2c5a30fa5e877d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b7d9f193338ffc2c5a30fa5e877d8d">&#9670;&#160;</a></span>getExecutionContext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> * <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::getExecutionContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current execution context. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#afc248c708f5c6c3e524bd461236a403b">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a9e863f641e7f9254e7fa800cd8c96dd4" name="a9e863f641e7f9254e7fa800cd8c96dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e863f641e7f9254e7fa800cd8c96dd4">&#9670;&#160;</a></span>applyCustomOperation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::applyCustomOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>customName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a custom quantum operation. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a35ddfc0b4789977d7ebcdcbfb862a814">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a9a80d89bcaf9d443b33089508ae1280b" name="a9a80d89bcaf9d443b33089508ae1280b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a80d89bcaf9d443b33089508ae1280b">&#9670;&#160;</a></span>u2() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::u2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a6e26d8a3ab86cf118d0d060f28ce26f1" name="a6e26d8a3ab86cf118d0d060f28ce26f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e26d8a3ab86cf118d0d060f28ce26f1">&#9670;&#160;</a></span>u3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::u3 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a31b3ae37690dc768845aa86b72fe883f" name="a31b3ae37690dc768845aa86b72fe883f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b3ae37690dc768845aa86b72fe883f">&#9670;&#160;</a></span>phased_rx() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::phased_rx </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a92596e1a3c470048b6443f5e44164fc9" name="a92596e1a3c470048b6443f5e44164fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92596e1a3c470048b6443f5e44164fc9">&#9670;&#160;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>srcIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>tgtIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a general multi-control swap gate. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a1f79da489b573f47dd0a3d06de07967c">nvqir::CircuitSimulator</a>.</p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a9356286a073cd3e68c97c3b39750953e">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a0944e6a666d0e436ecf2e927e2901dbd" name="a0944e6a666d0e436ecf2e927e2901dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0944e6a666d0e436ecf2e927e2901dbd">&#9670;&#160;</a></span>mz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::mz </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measure the qubit with given index. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a4f91a840b5d37a74dafe0b7f3fc16315">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="aa76554791ab3f3710de84ab86cacd45e" name="aa76554791ab3f3710de84ab86cacd45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76554791ab3f3710de84ab86cacd45e">&#9670;&#160;</a></span>mz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::mz </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>registerName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measure operation. Here we check what the current execution context is. If the context is sample, then we do nothing but store the measure qubit, which we then use to do full state sampling when flushAnySamplingTask() is called. If the context is sample-conditional, then we have a circuit that contains if (<code>mz(q)</code>) and we measure the qubit, collapse the state, and then store the sample qubit for final full state sampling. We also return the bit result. If no execution context, just measure, collapse, and return the bit. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a9e00d245e8f51b9ebc7ec48dca2db52e">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a473e81e11432addde5f36d9cbee1c193" name="a473e81e11432addde5f36d9cbee1c193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473e81e11432addde5f36d9cbee1c193">&#9670;&#160;</a></span>measureSpinOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::measureSpinOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a588d7a5de124177e650af2dad00a5bd8" name="a588d7a5de124177e650af2dad00a5bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588d7a5de124177e650af2dad00a5bd8">&#9670;&#160;</a></span>u2() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nvqir::CircuitSimulator::u2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The X gate. </p>
<p>The Y gate</p>
<p>The Z gate</p>
<p>The H gate</p>
<p>The S gate</p>
<p>The T gate</p>
<p>The Sdg gate</p>
<p>The Tdg gate</p>
<p>The RX gate</p>
<p>The RY gate</p>
<p>The RZ gate</p>
<p>The Phase gate</p>
<p>The IBM U1 gate </p>

</div>
</div>
<a id="aabc57806dbb5b84a58de2b3d2682e7fb" name="aabc57806dbb5b84a58de2b3d2682e7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc57806dbb5b84a58de2b3d2682e7fb">&#9670;&#160;</a></span>u2() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::u2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The X gate. </p>
<p>The Y gate</p>
<p>The Z gate</p>
<p>The H gate</p>
<p>The S gate</p>
<p>The T gate</p>
<p>The Sdg gate</p>
<p>The Tdg gate</p>
<p>The RX gate</p>
<p>The RY gate</p>
<p>The RZ gate</p>
<p>The Phase gate</p>
<p>The IBM U1 gate </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="abbe3419977322f608b96c902bfc23720" name="abbe3419977322f608b96c902bfc23720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe3419977322f608b96c902bfc23720">&#9670;&#160;</a></span>u3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::u3 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a9cf68d21cae760f7170cb8ded24d5356" name="a9cf68d21cae760f7170cb8ded24d5356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf68d21cae760f7170cb8ded24d5356">&#9670;&#160;</a></span>phased_rx() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::phased_rx </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html">nvqir::CircuitSimulator</a>.</p>

</div>
</div>
<a id="a1f79da489b573f47dd0a3d06de07967c" name="a1f79da489b573f47dd0a3d06de07967c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f79da489b573f47dd0a3d06de07967c">&#9670;&#160;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>srcIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>tgtIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a general multi-control swap gate. </p>

<p>Implements <a class="el" href="classnvqir_1_1CircuitSimulator.html#a1f79da489b573f47dd0a3d06de07967c">nvqir::CircuitSimulator</a>.</p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a9356286a073cd3e68c97c3b39750953e">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a8b16545255b68bf4c350a4e4a3a9d52a" name="a8b16545255b68bf4c350a4e4a3a9d52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b16545255b68bf4c350a4e4a3a9d52a">&#9670;&#160;</a></span>observeSamplingEnvVar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase</a>&lt; ScalarType &gt;::observeSamplingEnvVar[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      <span class="stringliteral">&quot;CUDAQ_OBSERVE_FROM_SAMPLING&quot;</span></div>
</div><!-- fragment -->
<p>Environment variable name that allows a programmer to specify how expectation values should be computed. This defaults to true. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/cuda-quantum/runtime/nvqir/<a class="el" href="CircuitSimulator_8h_source.html">CircuitSimulator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
