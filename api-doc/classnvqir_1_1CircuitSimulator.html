<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUDA-Q: nvqir::CircuitSimulator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CUDA-Q
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nvqir</b></li><li class="navelem"><a class="el" href="classnvqir_1_1CircuitSimulator.html">CircuitSimulator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">nvqir::CircuitSimulator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a> defines a base class for all simulators that are available to CUDA-Q via the NVQIR library. This base class handles <a class="el" href="structQubit.html">Qubit</a> allocation and deallocation, execution context handling, and defines all quantum operations pure virtual methods that subtypes must implement. Subtypes should be responsible for evolution of the concrete wave function representation (e.g., state vector), sampling, and measurements.  
 <a href="classnvqir_1_1CircuitSimulator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CircuitSimulator_8h_source.html">CircuitSimulator.h</a>&gt;</code></p>

<p>Inherited by <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase&lt; double &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47d22399823d9c78a8cf57173dc6b52a"><td class="memItemLeft" align="right" valign="top"><a id="a47d22399823d9c78a8cf57173dc6b52a" name="a47d22399823d9c78a8cf57173dc6b52a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CircuitSimulator</b> ()=default</td></tr>
<tr class="memdesc:a47d22399823d9c78a8cf57173dc6b52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor. <br /></td></tr>
<tr class="separator:a47d22399823d9c78a8cf57173dc6b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac024267d75a23fb69d235b21a64153bf"><td class="memItemLeft" align="right" valign="top"><a id="ac024267d75a23fb69d235b21a64153bf" name="ac024267d75a23fb69d235b21a64153bf"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~CircuitSimulator</b> ()=default</td></tr>
<tr class="memdesc:ac024267d75a23fb69d235b21a64153bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor. <br /></td></tr>
<tr class="separator:ac024267d75a23fb69d235b21a64153bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9626a65f7f66486b0753641d0039540e"><td class="memItemLeft" align="right" valign="top"><a id="a9626a65f7f66486b0753641d0039540e" name="a9626a65f7f66486b0753641d0039540e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flushGateQueue</b> ()</td></tr>
<tr class="memdesc:a9626a65f7f66486b0753641d0039540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the current queue of gates, i.e. apply them to the state. <br /></td></tr>
<tr class="separator:a9626a65f7f66486b0753641d0039540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea494aac7ce1db35fa9f0badb624c00d"><td class="memItemLeft" align="right" valign="top"><a id="aea494aac7ce1db35fa9f0badb624c00d" name="aea494aac7ce1db35fa9f0badb624c00d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>tearDownBeforeMPIFinalize</b> ()</td></tr>
<tr class="memdesc:aea494aac7ce1db35fa9f0badb624c00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an opportunity for any tear-down tasks before MPI Finalize is invoked. Here we leave this unimplemented, it is meant for subclasses. <br /></td></tr>
<tr class="separator:aea494aac7ce1db35fa9f0badb624c00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deadc9d6676b1ecf73232f36c819f80"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a2deadc9d6676b1ecf73232f36c819f80">createStateFromData</a> (const cudaq::state_data &amp;)=0</td></tr>
<tr class="memdesc:a2deadc9d6676b1ecf73232f36c819f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a mechanism for simulators to create and return a <code>SimulationState</code> instance from a user-specified data set.  <br /></td></tr>
<tr class="separator:a2deadc9d6676b1ecf73232f36c819f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae574715d2e8dc383622c1c59c7e7cf05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#ae574715d2e8dc383622c1c59c7e7cf05">setNoiseModel</a> (<a class="el" href="classcudaq_1_1noise__model.html">cudaq::noise_model</a> &amp;noise)=0</td></tr>
<tr class="memdesc:ae574715d2e8dc383622c1c59c7e7cf05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current noise model to consider when simulating the state. This should be overridden by simulation strategies that support noise modeling.  <br /></td></tr>
<tr class="separator:ae574715d2e8dc383622c1c59c7e7cf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc07efde90fa2b52209a9f4b3859babd"><td class="memItemLeft" align="right" valign="top"><a id="abc07efde90fa2b52209a9f4b3859babd" name="abc07efde90fa2b52209a9f4b3859babd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setRandomSeed</b> (std::size_t seed)</td></tr>
<tr class="separator:abc07efde90fa2b52209a9f4b3859babd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbbf18a22d4b5698a0fc30069824ef50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#adbbf18a22d4b5698a0fc30069824ef50">synchronize</a> ()</td></tr>
<tr class="memdesc:adbbf18a22d4b5698a0fc30069824ef50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any flushing or synchronization to force that all previously applied gates have truly been applied by the underlying simulator.  <br /></td></tr>
<tr class="separator:adbbf18a22d4b5698a0fc30069824ef50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf20fc4a8a18f1ea29472ec4198e9c6f"><td class="memItemLeft" align="right" valign="top"><a id="aaf20fc4a8a18f1ea29472ec4198e9c6f" name="aaf20fc4a8a18f1ea29472ec4198e9c6f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>applyExpPauli</b> (double theta, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; std::size_t &gt; &amp;qubitIds, const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;op)</td></tr>
<tr class="memdesc:aaf20fc4a8a18f1ea29472ec4198e9c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply exp(-i theta PauliTensorProd) to the underlying state. This must be provided by subclasses. <br /></td></tr>
<tr class="separator:aaf20fc4a8a18f1ea29472ec4198e9c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e070ba9b076835b153eedf21dcd4505"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcudaq_1_1observe__result.html">cudaq::observe_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a9e070ba9b076835b153eedf21dcd4505">observe</a> (const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;term)=0</td></tr>
<tr class="memdesc:a9e070ba9b076835b153eedf21dcd4505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the expected value of the given spin op with respect to the current state, &lt;psi | H | psi&gt;.  <br /></td></tr>
<tr class="separator:a9e070ba9b076835b153eedf21dcd4505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2905039c70f46417b4a660bb3620f84"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#ad2905039c70f46417b4a660bb3620f84">allocateQubit</a> ()=0</td></tr>
<tr class="memdesc:ad2905039c70f46417b4a660bb3620f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a single qubit, return the qubit as a logical index.  <br /></td></tr>
<tr class="separator:ad2905039c70f46417b4a660bb3620f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02bb6efa6b958b6365c1591bb5e5660"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#af02bb6efa6b958b6365c1591bb5e5660">allocateQubits</a> (std::size_t count, const void *state=nullptr, cudaq::simulation_precision precision=cudaq::simulation_precision::fp32)=0</td></tr>
<tr class="memdesc:af02bb6efa6b958b6365c1591bb5e5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate <code>count</code> qubits.  <br /></td></tr>
<tr class="separator:af02bb6efa6b958b6365c1591bb5e5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f1bec810fdfb1ed5af129f7ddb0835"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a27f1bec810fdfb1ed5af129f7ddb0835">allocateQubits</a> (std::size_t count, const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> *state)=0</td></tr>
<tr class="separator:a27f1bec810fdfb1ed5af129f7ddb0835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7410d4474aec0fd02a06d6f39ac620"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#afb7410d4474aec0fd02a06d6f39ac620">deallocate</a> (const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:afb7410d4474aec0fd02a06d6f39ac620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the qubit with give unique index.  <br /></td></tr>
<tr class="separator:afb7410d4474aec0fd02a06d6f39ac620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69469a664a9b28d82f9e441d3af05414"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a69469a664a9b28d82f9e441d3af05414">deallocateQubits</a> (const std::vector&lt; std::size_t &gt; &amp;qubits)=0</td></tr>
<tr class="memdesc:a69469a664a9b28d82f9e441d3af05414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate all the provided qubits.  <br /></td></tr>
<tr class="separator:a69469a664a9b28d82f9e441d3af05414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d30f87fa79e77ed6cb601db01357d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#ad3d30f87fa79e77ed6cb601db01357d4">resetExecutionContext</a> ()=0</td></tr>
<tr class="memdesc:ad3d30f87fa79e77ed6cb601db01357d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the current execution context.  <br /></td></tr>
<tr class="separator:ad3d30f87fa79e77ed6cb601db01357d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ba278d5a49474f22376831ef2e0d4d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a29ba278d5a49474f22376831ef2e0d4d">setExecutionContext</a> (<a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *context)=0</td></tr>
<tr class="memdesc:a29ba278d5a49474f22376831ef2e0d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the execution context.  <br /></td></tr>
<tr class="separator:a29ba278d5a49474f22376831ef2e0d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc248c708f5c6c3e524bd461236a403b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#afc248c708f5c6c3e524bd461236a403b">getExecutionContext</a> ()=0</td></tr>
<tr class="memdesc:afc248c708f5c6c3e524bd461236a403b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current execution context.  <br /></td></tr>
<tr class="separator:afc248c708f5c6c3e524bd461236a403b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dafa8b33cc39e9dcd6268f3331225c8"><td class="memItemLeft" align="right" valign="top"><a id="a7dafa8b33cc39e9dcd6268f3331225c8" name="a7dafa8b33cc39e9dcd6268f3331225c8"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isStateVectorSimulator</b> () const</td></tr>
<tr class="memdesc:a7dafa8b33cc39e9dcd6268f3331225c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not this is a state vector simulator. <br /></td></tr>
<tr class="separator:a7dafa8b33cc39e9dcd6268f3331225c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ddfc0b4789977d7ebcdcbfb862a814"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a35ddfc0b4789977d7ebcdcbfb862a814">applyCustomOperation</a> (const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;matrix, const std::vector&lt; std::size_t &gt; &amp;controls, const std::vector&lt; std::size_t &gt; &amp;targets, const std::string_view customUnitaryName=&quot;&quot;)=0</td></tr>
<tr class="memdesc:a35ddfc0b4789977d7ebcdcbfb862a814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a custom operation described by a matrix of data represented as 1-D vector of elements in row-major order, as well as the the control qubit and target indices.  <br /></td></tr>
<tr class="separator:a35ddfc0b4789977d7ebcdcbfb862a814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d7a5de124177e650af2dad00a5bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a588d7a5de124177e650af2dad00a5bd8">u2</a> (const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="memdesc:a588d7a5de124177e650af2dad00a5bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The X gate.  <br /></td></tr>
<tr class="separator:a588d7a5de124177e650af2dad00a5bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc57806dbb5b84a58de2b3d2682e7fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#aabc57806dbb5b84a58de2b3d2682e7fb">u2</a> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:aabc57806dbb5b84a58de2b3d2682e7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce475a223e738a422853f54e455f3ba"><td class="memItemLeft" align="right" valign="top"><a id="abce475a223e738a422853f54e455f3ba" name="abce475a223e738a422853f54e455f3ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>phased_rx</b> (const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="separator:abce475a223e738a422853f54e455f3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf68d21cae760f7170cb8ded24d5356"><td class="memItemLeft" align="right" valign="top"><a id="a9cf68d21cae760f7170cb8ded24d5356" name="a9cf68d21cae760f7170cb8ded24d5356"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>phased_rx</b> (const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:a9cf68d21cae760f7170cb8ded24d5356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0cd0283fe2b84ba73b00778fc09382"><td class="memItemLeft" align="right" valign="top"><a id="a9d0cd0283fe2b84ba73b00778fc09382" name="a9d0cd0283fe2b84ba73b00778fc09382"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>u3</b> (const double theta, const double phi, const double lambda, const std::size_t qubitIdx)</td></tr>
<tr class="separator:a9d0cd0283fe2b84ba73b00778fc09382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe3419977322f608b96c902bfc23720"><td class="memItemLeft" align="right" valign="top"><a id="abbe3419977322f608b96c902bfc23720" name="abbe3419977322f608b96c902bfc23720"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>u3</b> (const double theta, const double phi, const double lambda, const std::vector&lt; std::size_t &gt; &amp;controls, const std::size_t qubitIdx)=0</td></tr>
<tr class="separator:abbe3419977322f608b96c902bfc23720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1c8e220759e335acbc18817dd42509"><td class="memItemLeft" align="right" valign="top"><a id="a1a1c8e220759e335acbc18817dd42509" name="a1a1c8e220759e335acbc18817dd42509"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (const std::size_t srcIdx, const std::size_t tgtIdx)</td></tr>
<tr class="memdesc:a1a1c8e220759e335acbc18817dd42509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the SWAP gate. <br /></td></tr>
<tr class="separator:a1a1c8e220759e335acbc18817dd42509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f79da489b573f47dd0a3d06de07967c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a1f79da489b573f47dd0a3d06de07967c">swap</a> (const std::vector&lt; std::size_t &gt; &amp;ctrlBits, const std::size_t srcIdx, const std::size_t tgtIdx)=0</td></tr>
<tr class="memdesc:a1f79da489b573f47dd0a3d06de07967c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a general multi-control swap gate.  <br /></td></tr>
<tr class="separator:a1f79da489b573f47dd0a3d06de07967c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f91a840b5d37a74dafe0b7f3fc16315"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a4f91a840b5d37a74dafe0b7f3fc16315">mz</a> (const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:a4f91a840b5d37a74dafe0b7f3fc16315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the qubit with given index.  <br /></td></tr>
<tr class="separator:a4f91a840b5d37a74dafe0b7f3fc16315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e00d245e8f51b9ebc7ec48dca2db52e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a9e00d245e8f51b9ebc7ec48dca2db52e">mz</a> (const std::size_t qubitIdx, const std::string &amp;registerName)=0</td></tr>
<tr class="memdesc:a9e00d245e8f51b9ebc7ec48dca2db52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure operation. Here we check what the current execution context is. If the context is sample, then we do nothing but store the measure qubit, which we then use to do full state sampling when flushAnySamplingTask() is called. If the context is sample-conditional, then we have a circuit that contains if (<code>mz(q)</code>) and we measure the qubit, collapse the state, and then store the sample qubit for final full state sampling. We also return the bit result. If no execution context, just measure, collapse, and return the bit.  <br /></td></tr>
<tr class="separator:a9e00d245e8f51b9ebc7ec48dca2db52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b46c0caa94ec5b83365e5404b4895a6"><td class="memItemLeft" align="right" valign="top"><a id="a5b46c0caa94ec5b83365e5404b4895a6" name="a5b46c0caa94ec5b83365e5404b4895a6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>measureSpinOp</b> (const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;op)=0</td></tr>
<tr class="separator:a5b46c0caa94ec5b83365e5404b4895a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f47166da5758fbf736f6296ade3b67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a70f47166da5758fbf736f6296ade3b67">resetQubit</a> (const std::size_t qubitIdx)=0</td></tr>
<tr class="memdesc:a70f47166da5758fbf736f6296ade3b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the qubit to the |0&gt; state.  <br /></td></tr>
<tr class="separator:a70f47166da5758fbf736f6296ade3b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391aa9fe5634e67f340ef7bce0294bcb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structcudaq_1_1ExecutionResult.html">cudaq::ExecutionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a391aa9fe5634e67f340ef7bce0294bcb">sample</a> (const std::vector&lt; std::size_t &gt; &amp;qubitIdxs, const int shots)=0</td></tr>
<tr class="memdesc:a391aa9fe5634e67f340ef7bce0294bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample the current multi-qubit state on the given qubit indices over a certain number of shots.  <br /></td></tr>
<tr class="separator:a391aa9fe5634e67f340ef7bce0294bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e55127239da3d7bd57d0c623bd287c3"><td class="memItemLeft" align="right" valign="top"><a id="a5e55127239da3d7bd57d0c623bd287c3" name="a5e55127239da3d7bd57d0c623bd287c3"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const =0</td></tr>
<tr class="memdesc:a5e55127239da3d7bd57d0c623bd287c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a>. <br /></td></tr>
<tr class="separator:a5e55127239da3d7bd57d0c623bd287c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fa404ffe5cac5ee0afef9cb3129838"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnvqir_1_1CircuitSimulator.html">CircuitSimulator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a42fa404ffe5cac5ee0afef9cb3129838">clone</a> ()=0</td></tr>
<tr class="memdesc:a42fa404ffe5cac5ee0afef9cb3129838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a thread_local pointer to this <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a>.  <br /></td></tr>
<tr class="separator:a42fa404ffe5cac5ee0afef9cb3129838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4132e9eabbc6826c4728cfdaa1aca6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#a5e4132e9eabbc6826c4728cfdaa1aca6">isSinglePrecision</a> () const =0</td></tr>
<tr class="memdesc:a5e4132e9eabbc6826c4728cfdaa1aca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the (preferred) precision of the simulator.  <br /></td></tr>
<tr class="separator:a5e4132e9eabbc6826c4728cfdaa1aca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba71c9c4600be22d2950c918e65c5c05"><td class="memItemLeft" align="right" valign="top"><a id="aba71c9c4600be22d2950c918e65c5c05" name="aba71c9c4600be22d2950c918e65c5c05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDoublePrecision</b> () const</td></tr>
<tr class="separator:aba71c9c4600be22d2950c918e65c5c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af435eda7b0b1c3c80145ccfbae5e06af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvqir_1_1CircuitSimulator.html#af435eda7b0b1c3c80145ccfbae5e06af">flushGateQueueImpl</a> ()=0</td></tr>
<tr class="memdesc:af435eda7b0b1c3c80145ccfbae5e06af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the current queue of gates, i.e. apply them to the state. Internal and meant for subclasses to implement.  <br /></td></tr>
<tr class="separator:af435eda7b0b1c3c80145ccfbae5e06af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a62034e4bcf808c0756a1eb2b614bc408"><td class="memItemLeft" align="right" valign="top"><a id="a62034e4bcf808c0756a1eb2b614bc408" name="a62034e4bcf808c0756a1eb2b614bc408"></a>
<a class="el" href="structnvqir_1_1SummaryData.html">SummaryData</a>&#160;</td><td class="memItemRight" valign="bottom"><b>summaryData</b></td></tr>
<tr class="memdesc:a62034e4bcf808c0756a1eb2b614bc408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics collected over the life of the simulator. <br /></td></tr>
<tr class="separator:a62034e4bcf808c0756a1eb2b614bc408"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a> defines a base class for all simulators that are available to CUDA-Q via the NVQIR library. This base class handles <a class="el" href="structQubit.html">Qubit</a> allocation and deallocation, execution context handling, and defines all quantum operations pure virtual methods that subtypes must implement. Subtypes should be responsible for evolution of the concrete wave function representation (e.g., state vector), sampling, and measurements. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af435eda7b0b1c3c80145ccfbae5e06af" name="af435eda7b0b1c3c80145ccfbae5e06af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af435eda7b0b1c3c80145ccfbae5e06af">&#9670;&#160;</a></span>flushGateQueueImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::flushGateQueueImpl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the current queue of gates, i.e. apply them to the state. Internal and meant for subclasses to implement. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a18c8390993b4f5269cce9eeb00f6101c">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a18c8390993b4f5269cce9eeb00f6101c">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a2deadc9d6676b1ecf73232f36c819f80" name="a2deadc9d6676b1ecf73232f36c819f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2deadc9d6676b1ecf73232f36c819f80">&#9670;&#160;</a></span>createStateFromData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt; nvqir::CircuitSimulator::createStateFromData </td>
          <td>(</td>
          <td class="paramtype">const cudaq::state_data &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a mechanism for simulators to create and return a <code>SimulationState</code> instance from a user-specified data set. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a3cc00ca0015d1a941ee5974327f47826">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a3cc00ca0015d1a941ee5974327f47826">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ae574715d2e8dc383622c1c59c7e7cf05" name="ae574715d2e8dc383622c1c59c7e7cf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae574715d2e8dc383622c1c59c7e7cf05">&#9670;&#160;</a></span>setNoiseModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::setNoiseModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudaq_1_1noise__model.html">cudaq::noise_model</a> &amp;&#160;</td>
          <td class="paramname"><em>noise</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current noise model to consider when simulating the state. This should be overridden by simulation strategies that support noise modeling. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ae95ee18d416e23546aa01ef4d00722d5">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ae95ee18d416e23546aa01ef4d00722d5">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="adbbf18a22d4b5698a0fc30069824ef50" name="adbbf18a22d4b5698a0fc30069824ef50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbbf18a22d4b5698a0fc30069824ef50">&#9670;&#160;</a></span>synchronize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::synchronize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any flushing or synchronization to force that all previously applied gates have truly been applied by the underlying simulator. </p>

<p>Reimplemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#aeb9575ceff8d9ffc49436325bb79ee58">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a9e070ba9b076835b153eedf21dcd4505" name="a9e070ba9b076835b153eedf21dcd4505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e070ba9b076835b153eedf21dcd4505">&#9670;&#160;</a></span>observe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcudaq_1_1observe__result.html">cudaq::observe_result</a> nvqir::CircuitSimulator::observe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcudaq_1_1spin__op.html">cudaq::spin_op</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the expected value of the given spin op with respect to the current state, &lt;psi | H | psi&gt;. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#ae7b6971782f7d0d9d619803488f7bed6">nvqir::SimulatorTensorNetBase</a>, <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aa52476e6ee21a3921dd6046ab4d3678e">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aa52476e6ee21a3921dd6046ab4d3678e">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ad2905039c70f46417b4a660bb3620f84" name="ad2905039c70f46417b4a660bb3620f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2905039c70f46417b4a660bb3620f84">&#9670;&#160;</a></span>allocateQubit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t nvqir::CircuitSimulator::allocateQubit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a single qubit, return the qubit as a logical index. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a985f3ea7ac944dba1bc7097ca3dc865b">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a985f3ea7ac944dba1bc7097ca3dc865b">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="af02bb6efa6b958b6365c1591bb5e5660" name="af02bb6efa6b958b6365c1591bb5e5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02bb6efa6b958b6365c1591bb5e5660">&#9670;&#160;</a></span>allocateQubits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::size_t &gt; nvqir::CircuitSimulator::allocateQubits </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>state</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaq::simulation_precision&#160;</td>
          <td class="paramname"><em>precision</em> = <code>cudaq::simulation_precision::fp32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate <code>count</code> qubits. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ac752abf42c181cec2c4171ef5258912f">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ac752abf42c181cec2c4171ef5258912f">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a27f1bec810fdfb1ed5af129f7ddb0835" name="a27f1bec810fdfb1ed5af129f7ddb0835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f1bec810fdfb1ed5af129f7ddb0835">&#9670;&#160;</a></span>allocateQubits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::size_t &gt; nvqir::CircuitSimulator::allocateQubits </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a0f327c013941fab7971299990658f9d9">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a0f327c013941fab7971299990658f9d9">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="afb7410d4474aec0fd02a06d6f39ac620" name="afb7410d4474aec0fd02a06d6f39ac620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7410d4474aec0fd02a06d6f39ac620">&#9670;&#160;</a></span>deallocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::deallocate </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate the qubit with give unique index. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a54fd3292dbbbfefb2b7ed9253fd55a05">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a54fd3292dbbbfefb2b7ed9253fd55a05">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a69469a664a9b28d82f9e441d3af05414" name="a69469a664a9b28d82f9e441d3af05414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69469a664a9b28d82f9e441d3af05414">&#9670;&#160;</a></span>deallocateQubits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::deallocateQubits </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>qubits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocate all the provided qubits. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ae21b6d1a25fe767fc492fc700323d0c5">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#ae21b6d1a25fe767fc492fc700323d0c5">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="ad3d30f87fa79e77ed6cb601db01357d4" name="ad3d30f87fa79e77ed6cb601db01357d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d30f87fa79e77ed6cb601db01357d4">&#9670;&#160;</a></span>resetExecutionContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::resetExecutionContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the current execution context. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a3c8c85f8f92fcc5a6bdf8c6ba73a4339">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a3c8c85f8f92fcc5a6bdf8c6ba73a4339">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a29ba278d5a49474f22376831ef2e0d4d" name="a29ba278d5a49474f22376831ef2e0d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ba278d5a49474f22376831ef2e0d4d">&#9670;&#160;</a></span>setExecutionContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::setExecutionContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the execution context. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aed5e6f033833c8f5145f91c3ec164634">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aed5e6f033833c8f5145f91c3ec164634">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="afc248c708f5c6c3e524bd461236a403b" name="afc248c708f5c6c3e524bd461236a403b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc248c708f5c6c3e524bd461236a403b">&#9670;&#160;</a></span>getExecutionContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcudaq_1_1ExecutionContext.html">cudaq::ExecutionContext</a> * nvqir::CircuitSimulator::getExecutionContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current execution context. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a00b7d9f193338ffc2c5a30fa5e877d8d">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a00b7d9f193338ffc2c5a30fa5e877d8d">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a35ddfc0b4789977d7ebcdcbfb862a814" name="a35ddfc0b4789977d7ebcdcbfb862a814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ddfc0b4789977d7ebcdcbfb862a814">&#9670;&#160;</a></span>applyCustomOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::applyCustomOperation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>customUnitaryName</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a custom operation described by a matrix of data represented as 1-D vector of elements in row-major order, as well as the the control qubit and target indices. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a9e863f641e7f9254e7fa800cd8c96dd4">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a9e863f641e7f9254e7fa800cd8c96dd4">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a588d7a5de124177e650af2dad00a5bd8" name="a588d7a5de124177e650af2dad00a5bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588d7a5de124177e650af2dad00a5bd8">&#9670;&#160;</a></span>u2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nvqir::CircuitSimulator::u2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The X gate. </p>
<p>The Y gate</p>
<p>The Z gate</p>
<p>The H gate</p>
<p>The S gate</p>
<p>The T gate</p>
<p>The Sdg gate</p>
<p>The Tdg gate</p>
<p>The RX gate</p>
<p>The RY gate</p>
<p>The RZ gate</p>
<p>The Phase gate</p>
<p>The IBM U1 gate </p>

</div>
</div>
<a id="aabc57806dbb5b84a58de2b3d2682e7fb" name="aabc57806dbb5b84a58de2b3d2682e7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc57806dbb5b84a58de2b3d2682e7fb">&#9670;&#160;</a></span>u2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::u2 </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>controls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aabc57806dbb5b84a58de2b3d2682e7fb">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aabc57806dbb5b84a58de2b3d2682e7fb">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a1f79da489b573f47dd0a3d06de07967c" name="a1f79da489b573f47dd0a3d06de07967c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f79da489b573f47dd0a3d06de07967c">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::swap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctrlBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>srcIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>tgtIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke a general multi-control swap gate. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a92596e1a3c470048b6443f5e44164fc9">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a92596e1a3c470048b6443f5e44164fc9">nvqir::CircuitSimulatorBase&lt; double &gt;</a>, <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a9356286a073cd3e68c97c3b39750953e">nvqir::SimulatorTensorNetBase</a>, <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a1f79da489b573f47dd0a3d06de07967c">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a1f79da489b573f47dd0a3d06de07967c">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a4f91a840b5d37a74dafe0b7f3fc16315" name="a4f91a840b5d37a74dafe0b7f3fc16315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f91a840b5d37a74dafe0b7f3fc16315">&#9670;&#160;</a></span>mz() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvqir::CircuitSimulator::mz </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measure the qubit with given index. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a0944e6a666d0e436ecf2e927e2901dbd">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#a0944e6a666d0e436ecf2e927e2901dbd">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a9e00d245e8f51b9ebc7ec48dca2db52e" name="a9e00d245e8f51b9ebc7ec48dca2db52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e00d245e8f51b9ebc7ec48dca2db52e">&#9670;&#160;</a></span>mz() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvqir::CircuitSimulator::mz </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>registerName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Measure operation. Here we check what the current execution context is. If the context is sample, then we do nothing but store the measure qubit, which we then use to do full state sampling when flushAnySamplingTask() is called. If the context is sample-conditional, then we have a circuit that contains if (<code>mz(q)</code>) and we measure the qubit, collapse the state, and then store the sample qubit for final full state sampling. We also return the bit result. If no execution context, just measure, collapse, and return the bit. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aa76554791ab3f3710de84ab86cacd45e">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#aa76554791ab3f3710de84ab86cacd45e">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<a id="a70f47166da5758fbf736f6296ade3b67" name="a70f47166da5758fbf736f6296ade3b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f47166da5758fbf736f6296ade3b67">&#9670;&#160;</a></span>resetQubit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nvqir::CircuitSimulator::resetQubit </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>qubitIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the qubit to the |0&gt; state. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a8a0ea4c1ca0f33b0034a99fbbcedbfbd">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a391aa9fe5634e67f340ef7bce0294bcb" name="a391aa9fe5634e67f340ef7bce0294bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391aa9fe5634e67f340ef7bce0294bcb">&#9670;&#160;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structcudaq_1_1ExecutionResult.html">cudaq::ExecutionResult</a> nvqir::CircuitSimulator::sample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>qubitIdxs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample the current multi-qubit state on the given qubit indices over a certain number of shots. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#aa1e1471a70de6d94ea8673bb6a46a59e">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a42fa404ffe5cac5ee0afef9cb3129838" name="a42fa404ffe5cac5ee0afef9cb3129838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fa404ffe5cac5ee0afef9cb3129838">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnvqir_1_1CircuitSimulator.html">CircuitSimulator</a> * nvqir::CircuitSimulator::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a thread_local pointer to this <a class="el" href="classnvqir_1_1CircuitSimulator.html" title="The CircuitSimulator defines a base class for all simulators that are available to CUDA-Q via the NVQ...">CircuitSimulator</a>. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1SimulatorTensorNetBase.html#a81d44b5e8f256e5eba93475e19003e6e">nvqir::SimulatorTensorNetBase</a>.</p>

</div>
</div>
<a id="a5e4132e9eabbc6826c4728cfdaa1aca6" name="a5e4132e9eabbc6826c4728cfdaa1aca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4132e9eabbc6826c4728cfdaa1aca6">&#9670;&#160;</a></span>isSinglePrecision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nvqir::CircuitSimulator::isSinglePrecision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the (preferred) precision of the simulator. </p>

<p>Implemented in <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#acd9c8029c1c1f4eea5614dc6363a07b2">nvqir::CircuitSimulatorBase&lt; ScalarType &gt;</a>, and <a class="el" href="classnvqir_1_1CircuitSimulatorBase.html#acd9c8029c1c1f4eea5614dc6363a07b2">nvqir::CircuitSimulatorBase&lt; double &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/cuda-quantum/runtime/nvqir/<a class="el" href="CircuitSimulator_8h_source.html">CircuitSimulator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
