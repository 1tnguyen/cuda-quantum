<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUDA-Q: cudaq::CusvState&lt; ScalarType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CUDA-Q
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cudaq</b></li><li class="navelem"><a class="el" href="classcudaq_1_1CusvState.html">CusvState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">cudaq::CusvState&lt; ScalarType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classcudaq_1_1CusvState.html" title="CusvState provides an implementation of SimulationState that encapsulates the state data for the Cust...">CusvState</a> provides an implementation of <code><a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a></code> that encapsulates the state data for the Custatevec Circuit Simulator. It attempts to keep the simulation data on GPU device and care is taken to ensure operations and comparisons with other states operate on compatible floating point element types.  
 <a href="classcudaq_1_1CusvState.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="CuStateVecState_8h_source.html">CuStateVecState.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a378b3520ceecbdce7e54ed96a303f1bc"><td class="memItemLeft" align="right" valign="top"><a id="a378b3520ceecbdce7e54ed96a303f1bc" name="a378b3520ceecbdce7e54ed96a303f1bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CusvState</b> (std::size_t s, void *ptr)</td></tr>
<tr class="separator:a378b3520ceecbdce7e54ed96a303f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49721e7fd60492e9c9de783798ff2af8"><td class="memItemLeft" align="right" valign="top"><a id="a49721e7fd60492e9c9de783798ff2af8" name="a49721e7fd60492e9c9de783798ff2af8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CusvState</b> (std::size_t s, void *ptr, bool owns)</td></tr>
<tr class="separator:a49721e7fd60492e9c9de783798ff2af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1748f7449a45d4f803248a11f11a944c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a1748f7449a45d4f803248a11f11a944c">getNumQubits</a> () const override</td></tr>
<tr class="memdesc:a1748f7449a45d4f803248a11f11a944c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of qubits this state models.  <br /></td></tr>
<tr class="separator:a1748f7449a45d4f803248a11f11a944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cffeeab8612e63d92d06583f1023bd8"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a8cffeeab8612e63d92d06583f1023bd8">overlap</a> (const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &amp;other) override</td></tr>
<tr class="memdesc:a8cffeeab8612e63d92d06583f1023bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the overlap of this state with the provided one. If the other state is not on GPU device, this function will copy the data from host.  <br /></td></tr>
<tr class="separator:a8cffeeab8612e63d92d06583f1023bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961307f4aa6d38c9a559bb9871dbb5f5"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a961307f4aa6d38c9a559bb9871dbb5f5">getAmplitude</a> (const std::vector&lt; int &gt; &amp;basisState) override</td></tr>
<tr class="memdesc:a961307f4aa6d38c9a559bb9871dbb5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amplitude of the given computational basis state.  <br /></td></tr>
<tr class="separator:a961307f4aa6d38c9a559bb9871dbb5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cba4bf3d8ff4c59bc0381789cf286c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a4cba4bf3d8ff4c59bc0381789cf286c7">dump</a> (std::ostream &amp;os) const override</td></tr>
<tr class="memdesc:a4cba4bf3d8ff4c59bc0381789cf286c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the state to the given output stream.  <br /></td></tr>
<tr class="separator:a4cba4bf3d8ff4c59bc0381789cf286c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05469f38e805082d96bf420b87742e56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a05469f38e805082d96bf420b87742e56">isDeviceData</a> () const override</td></tr>
<tr class="memdesc:a05469f38e805082d96bf420b87742e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is GPU device data, always return true.  <br /></td></tr>
<tr class="separator:a05469f38e805082d96bf420b87742e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe709c0e1c80f88ac76b8c2e9e71c33"><td class="memItemLeft" align="right" valign="top"><a id="abbe709c0e1c80f88ac76b8c2e9e71c33" name="abbe709c0e1c80f88ac76b8c2e9e71c33"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>getDevicePointer</b> () const</td></tr>
<tr class="memdesc:abbe709c0e1c80f88ac76b8c2e9e71c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device pointer. <br /></td></tr>
<tr class="separator:abbe709c0e1c80f88ac76b8c2e9e71c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addff9a1d38716e13ed6ab99d601ccc30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudaq_1_1SimulationState.html#a3fd90ce5445534e830b461b43b3dcf2f">precision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#addff9a1d38716e13ed6ab99d601ccc30">getPrecision</a> () const override</td></tr>
<tr class="memdesc:addff9a1d38716e13ed6ab99d601ccc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the precision of the state data elements.  <br /></td></tr>
<tr class="separator:addff9a1d38716e13ed6ab99d601ccc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769bb259d85ec0abfdfd7162a4fbc26e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">SimulationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a769bb259d85ec0abfdfd7162a4fbc26e">createFromSizeAndPtr</a> (std::size_t size, void *ptr, std::size_t type) override</td></tr>
<tr class="memdesc:a769bb259d85ec0abfdfd7162a4fbc26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass-specific creator method for new <a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a> instances. Create from the size and data pointer, which may be on GPU device.  <br /></td></tr>
<tr class="separator:a769bb259d85ec0abfdfd7162a4fbc26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf56e97e00bd744400f3d35f1d6f032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudaq_1_1SimulationState_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a4cf56e97e00bd744400f3d35f1d6f032">getTensor</a> (std::size_t tensorIdx=0) const override</td></tr>
<tr class="memdesc:a4cf56e97e00bd744400f3d35f1d6f032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tensor at the given index. Throws for an invalid tensor index.  <br /></td></tr>
<tr class="separator:a4cf56e97e00bd744400f3d35f1d6f032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76f320bc44b49f22ea9cca308146e0b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcudaq_1_1SimulationState_1_1Tensor.html">Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#af76f320bc44b49f22ea9cca308146e0b">getTensors</a> () const override</td></tr>
<tr class="memdesc:af76f320bc44b49f22ea9cca308146e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all tensors that represent this state.  <br /></td></tr>
<tr class="separator:af76f320bc44b49f22ea9cca308146e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c779c25762e8aa3bb6be8f0e59e508"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a87c779c25762e8aa3bb6be8f0e59e508">getNumTensors</a> () const override</td></tr>
<tr class="memdesc:a87c779c25762e8aa3bb6be8f0e59e508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of tensors that represent this state.  <br /></td></tr>
<tr class="separator:a87c779c25762e8aa3bb6be8f0e59e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f31b51fdfc0dee1f305ac03cda0809"><td class="memItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a52f31b51fdfc0dee1f305ac03cda0809">operator()</a> (std::size_t tensorIdx, const std::vector&lt; std::size_t &gt; &amp;indices) override</td></tr>
<tr class="memdesc:a52f31b51fdfc0dee1f305ac03cda0809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element from the tensor at the given tensor index and at the given indices.  <br /></td></tr>
<tr class="separator:a52f31b51fdfc0dee1f305ac03cda0809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff9c9093f8ee47ecafa8ff02d20111d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#abff9c9093f8ee47ecafa8ff02d20111d">toHost</a> (std::complex&lt; double &gt; *userData, std::size_t numElements) const override</td></tr>
<tr class="memdesc:abff9c9093f8ee47ecafa8ff02d20111d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the state device data to the user-provided host data pointer.  <br /></td></tr>
<tr class="separator:abff9c9093f8ee47ecafa8ff02d20111d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d96cc1f0b60e6953732be53bcfa3df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#ad3d96cc1f0b60e6953732be53bcfa3df">toHost</a> (std::complex&lt; float &gt; *userData, std::size_t numElements) const override</td></tr>
<tr class="memdesc:ad3d96cc1f0b60e6953732be53bcfa3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the state device data to the user-provided host data pointer.  <br /></td></tr>
<tr class="separator:ad3d96cc1f0b60e6953732be53bcfa3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ce242ebff2bd3f127c05320a27418e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1CusvState.html#a67ce242ebff2bd3f127c05320a27418e">destroyState</a> () override</td></tr>
<tr class="memdesc:a67ce242ebff2bd3f127c05320a27418e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the device data.  <br /></td></tr>
<tr class="separator:a67ce242ebff2bd3f127c05320a27418e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcudaq_1_1SimulationState"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcudaq_1_1SimulationState')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a></td></tr>
<tr class="memitem:a8c3198d3c2ade29e51b864fa508db4b1 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">
virtual std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createFromData</b> (const state_data &amp;data)</td></tr>
<tr class="memdesc:a8c3198d3c2ade29e51b864fa508db4b1 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new subclass specific <a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a> from the user provided data set. <br /></td></tr>
<tr class="separator:a8c3198d3c2ade29e51b864fa508db4b1 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bdff9f8c2fa8b0a4eb8b3bf6cb900a inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structcudaq_1_1SimulationState_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a92bdff9f8c2fa8b0a4eb8b3bf6cb900a">getTensor</a> (std::size_t tensorIdx=0) const =0</td></tr>
<tr class="memdesc:a92bdff9f8c2fa8b0a4eb8b3bf6cb900a inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tensor at the given index. Throws for an invalid tensor index.  <br /></td></tr>
<tr class="separator:a92bdff9f8c2fa8b0a4eb8b3bf6cb900a inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae282133b9dcf7492881c2bd4702f4a69 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structcudaq_1_1SimulationState_1_1Tensor.html">Tensor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#ae282133b9dcf7492881c2bd4702f4a69">getTensors</a> () const =0</td></tr>
<tr class="memdesc:ae282133b9dcf7492881c2bd4702f4a69 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all tensors that represent this state.  <br /></td></tr>
<tr class="separator:ae282133b9dcf7492881c2bd4702f4a69 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2e7e11d1d38f8aac9f7b728258ed84 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a9a2e7e11d1d38f8aac9f7b728258ed84">getNumTensors</a> () const =0</td></tr>
<tr class="memdesc:a9a2e7e11d1d38f8aac9f7b728258ed84 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of tensors that represent this state.  <br /></td></tr>
<tr class="separator:a9a2e7e11d1d38f8aac9f7b728258ed84 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ac27c6321edcc47ef21a6a335ebfd4 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a27ac27c6321edcc47ef21a6a335ebfd4">getNumQubits</a> () const =0</td></tr>
<tr class="memdesc:a27ac27c6321edcc47ef21a6a335ebfd4 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of qubits this state represents.  <br /></td></tr>
<tr class="separator:a27ac27c6321edcc47ef21a6a335ebfd4 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303d2b1d55b4987dc9b70d0150da7bbf inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a303d2b1d55b4987dc9b70d0150da7bbf">overlap</a> (const <a class="el" href="classcudaq_1_1SimulationState.html">SimulationState</a> &amp;other)=0</td></tr>
<tr class="memdesc:a303d2b1d55b4987dc9b70d0150da7bbf inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the overlap of this state representation with the provided <code>other</code> state, e.g. <code>|&lt;this | other&gt;|</code>.  <br /></td></tr>
<tr class="separator:a303d2b1d55b4987dc9b70d0150da7bbf inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efbcc89b3d3db0ed06acc2ff7863db0 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a7efbcc89b3d3db0ed06acc2ff7863db0">getAmplitude</a> (const std::vector&lt; int &gt; &amp;basisState)=0</td></tr>
<tr class="memdesc:a7efbcc89b3d3db0ed06acc2ff7863db0 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amplitude of the given computational basis state.  <br /></td></tr>
<tr class="separator:a7efbcc89b3d3db0ed06acc2ff7863db0 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c2f1514f517f058bf01ec52e67d92 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::complex&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#abc4c2f1514f517f058bf01ec52e67d92">getAmplitudes</a> (const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;basisStates)</td></tr>
<tr class="memdesc:abc4c2f1514f517f058bf01ec52e67d92 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the amplitudes of the given list of computational basis states.  <br /></td></tr>
<tr class="separator:abc4c2f1514f517f058bf01ec52e67d92 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e18cec691f4451d25e571edc541d8f inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a08e18cec691f4451d25e571edc541d8f">dump</a> (std::ostream &amp;os) const =0</td></tr>
<tr class="memdesc:a08e18cec691f4451d25e571edc541d8f inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a representation of the state to the given output stream.  <br /></td></tr>
<tr class="separator:a08e18cec691f4451d25e571edc541d8f inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8e0ea7f6b13a29453c4564ddbc8452 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcudaq_1_1SimulationState.html#a3fd90ce5445534e830b461b43b3dcf2f">precision</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#aea8e0ea7f6b13a29453c4564ddbc8452">getPrecision</a> () const =0</td></tr>
<tr class="separator:aea8e0ea7f6b13a29453c4564ddbc8452 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6bd1e6a1827b12e4177d7b9e24ac3e inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#acc6bd1e6a1827b12e4177d7b9e24ac3e">destroyState</a> ()=0</td></tr>
<tr class="memdesc:acc6bd1e6a1827b12e4177d7b9e24ac3e inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the state representation, frees all associated memory.  <br /></td></tr>
<tr class="separator:acc6bd1e6a1827b12e4177d7b9e24ac3e inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4303d5f74509a13f94be5700b709d74 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#ad4303d5f74509a13f94be5700b709d74">operator()</a> (std::size_t tensorIdx, const std::vector&lt; std::size_t &gt; &amp;indices)</td></tr>
<tr class="memdesc:ad4303d5f74509a13f94be5700b709d74 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element from the tensor at the given tensor index and at the given indices.  <br /></td></tr>
<tr class="separator:ad4303d5f74509a13f94be5700b709d74 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa517a54c6a67090522a0b5feb5f5744 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">
virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumElements</b> () const</td></tr>
<tr class="memdesc:afa517a54c6a67090522a0b5feb5f5744 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of elements in this state representation. Defaults to adding all shape elements. <br /></td></tr>
<tr class="separator:afa517a54c6a67090522a0b5feb5f5744 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09a5b439d603876d1efee754187a07e inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#aa09a5b439d603876d1efee754187a07e">isDeviceData</a> () const</td></tr>
<tr class="memdesc:aa09a5b439d603876d1efee754187a07e inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <code><a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a></code> wraps data on the GPU.  <br /></td></tr>
<tr class="separator:aa09a5b439d603876d1efee754187a07e inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac808643ca185c5de61bfc34d50df2311 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#ac808643ca185c5de61bfc34d50df2311">isArrayLike</a> () const</td></tr>
<tr class="memdesc:ac808643ca185c5de61bfc34d50df2311 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this <code><a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a></code> wraps contiguous memory (array-like).  <br /></td></tr>
<tr class="separator:ac808643ca185c5de61bfc34d50df2311 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9176de37f8740e6e33415e183c24d447 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a9176de37f8740e6e33415e183c24d447">toHost</a> (std::complex&lt; double &gt; *clientAllocatedData, std::size_t numElements) const</td></tr>
<tr class="memdesc:a9176de37f8740e6e33415e183c24d447 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data from device to host, return the data to the pointer provided by the client. Clients must specify the number of elements.  <br /></td></tr>
<tr class="separator:a9176de37f8740e6e33415e183c24d447 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2d1f8d95c25f46ba515c2ecb79d1c5 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#ace2d1f8d95c25f46ba515c2ecb79d1c5">toHost</a> (std::complex&lt; float &gt; *clientAllocatedData, std::size_t numElements) const</td></tr>
<tr class="memdesc:ace2d1f8d95c25f46ba515c2ecb79d1c5 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer data from device to host, return the data to the pointer provided by the client. Clients must specify the number of elements.  <br /></td></tr>
<tr class="separator:ace2d1f8d95c25f46ba515c2ecb79d1c5 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e53dd85c9072e2655f3a9f68ee2d890 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~SimulationState</b> ()</td></tr>
<tr class="memdesc:a2e53dd85c9072e2655f3a9f68ee2d890 inherit pub_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a2e53dd85c9072e2655f3a9f68ee2d890 inherit pub_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcudaq_1_1SimulationState"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcudaq_1_1SimulationState')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a></td></tr>
<tr class="memitem:a3fd90ce5445534e830b461b43b3dcf2f inherit pub_types_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top"><a id="a3fd90ce5445534e830b461b43b3dcf2f" name="a3fd90ce5445534e830b461b43b3dcf2f"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#a3fd90ce5445534e830b461b43b3dcf2f">precision</a> { <b>fp32</b>
, <b>fp64</b>
 }</td></tr>
<tr class="memdesc:a3fd90ce5445534e830b461b43b3dcf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime-known precision for the simulation data. <br /></td></tr>
<tr class="separator:a3fd90ce5445534e830b461b43b3dcf2f inherit pub_types_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcudaq_1_1SimulationState"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcudaq_1_1SimulationState')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a></td></tr>
<tr class="memitem:a10a0ee3392f16eac7695702e9bb03602 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:a10a0ee3392f16eac7695702e9bb03602 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getSizeAndPtrFromVec</b> (const state_data &amp;data)</td></tr>
<tr class="memdesc:a10a0ee3392f16eac7695702e9bb03602 inherit pro_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to inspect the state_data variant and extract the data pointer and size. <br /></td></tr>
<tr class="separator:a10a0ee3392f16eac7695702e9bb03602 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf25455f393537d53db603560ec5a16 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memTemplParams" colspan="2">
template&lt;typename T , typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:abaf25455f393537d53db603560ec5a16 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getSizeAndPtrFromPair</b> (const state_data &amp;data)</td></tr>
<tr class="memdesc:abaf25455f393537d53db603560ec5a16 inherit pro_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to inspect the state_data variant and extract the data pointer and size. <br /></td></tr>
<tr class="separator:abaf25455f393537d53db603560ec5a16 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9595e8964c56d9334eafced43b83f5f6 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memTemplParams" colspan="2">
template&lt;typename ScalarType  = double&gt; </td></tr>
<tr class="memitem:a9595e8964c56d9334eafced43b83f5f6 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getSizeAndPtr</b> (const state_data &amp;data)</td></tr>
<tr class="memdesc:a9595e8964c56d9334eafced43b83f5f6 inherit pro_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to inspect the state_data variant and extract the data pointer and size. <br /></td></tr>
<tr class="separator:a9595e8964c56d9334eafced43b83f5f6 inherit pro_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f7f11240719f8be9f90b458cd0e6ae inherit pro_methods_classcudaq_1_1SimulationState"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">SimulationState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudaq_1_1SimulationState.html#aa6f7f11240719f8be9f90b458cd0e6ae">createFromSizeAndPtr</a> (std::size_t, void *, std::size_t dataType)=0</td></tr>
<tr class="memdesc:aa6f7f11240719f8be9f90b458cd0e6ae inherit pro_methods_classcudaq_1_1SimulationState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass-specific creator method for new <a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a> instances. Create from the size and data pointer, which may be on GPU device.  <br /></td></tr>
<tr class="separator:aa6f7f11240719f8be9f90b458cd0e6ae inherit pro_methods_classcudaq_1_1SimulationState"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ScalarType&gt;<br />
class cudaq::CusvState&lt; ScalarType &gt;</div><p><a class="el" href="classcudaq_1_1CusvState.html" title="CusvState provides an implementation of SimulationState that encapsulates the state data for the Cust...">CusvState</a> provides an implementation of <code><a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a></code> that encapsulates the state data for the Custatevec Circuit Simulator. It attempts to keep the simulation data on GPU device and care is taken to ensure operations and comparisons with other states operate on compatible floating point element types. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1748f7449a45d4f803248a11f11a944c" name="a1748f7449a45d4f803248a11f11a944c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1748f7449a45d4f803248a11f11a944c">&#9670;&#160;</a></span>getNumQubits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::getNumQubits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of qubits this state models. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#a27ac27c6321edcc47ef21a6a335ebfd4">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a8cffeeab8612e63d92d06583f1023bd8" name="a8cffeeab8612e63d92d06583f1023bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cffeeab8612e63d92d06583f1023bd8">&#9670;&#160;</a></span>overlap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the overlap of this state with the provided one. If the other state is not on GPU device, this function will copy the data from host. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#a303d2b1d55b4987dc9b70d0150da7bbf">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a961307f4aa6d38c9a559bb9871dbb5f5" name="a961307f4aa6d38c9a559bb9871dbb5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961307f4aa6d38c9a559bb9871dbb5f5">&#9670;&#160;</a></span>getAmplitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::getAmplitude </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>basisState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the amplitude of the given computational basis state. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#a7efbcc89b3d3db0ed06acc2ff7863db0">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a4cba4bf3d8ff4c59bc0381789cf286c7" name="a4cba4bf3d8ff4c59bc0381789cf286c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cba4bf3d8ff4c59bc0381789cf286c7">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump the state to the given output stream. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#a08e18cec691f4451d25e571edc541d8f">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a05469f38e805082d96bf420b87742e56" name="a05469f38e805082d96bf420b87742e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05469f38e805082d96bf420b87742e56">&#9670;&#160;</a></span>isDeviceData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::isDeviceData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This state is GPU device data, always return true. </p>

<p>Reimplemented from <a class="el" href="classcudaq_1_1SimulationState.html#aa09a5b439d603876d1efee754187a07e">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="addff9a1d38716e13ed6ab99d601ccc30" name="addff9a1d38716e13ed6ab99d601ccc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addff9a1d38716e13ed6ab99d601ccc30">&#9670;&#160;</a></span>getPrecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudaq_1_1SimulationState.html#a3fd90ce5445534e830b461b43b3dcf2f">precision</a> <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::getPrecision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the precision of the state data elements. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a769bb259d85ec0abfdfd7162a4fbc26e" name="a769bb259d85ec0abfdfd7162a4fbc26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a769bb259d85ec0abfdfd7162a4fbc26e">&#9670;&#160;</a></span>createFromSizeAndPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudaq_1_1SimulationState.html">SimulationState</a> &gt; <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::createFromSizeAndPtr </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>dataType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subclass-specific creator method for new <a class="el" href="classcudaq_1_1SimulationState.html" title="The SimulationState interface provides and extension point for concrete circuit simulation sub-types ...">SimulationState</a> instances. Create from the size and data pointer, which may be on GPU device. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#aa6f7f11240719f8be9f90b458cd0e6ae">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a4cf56e97e00bd744400f3d35f1d6f032" name="a4cf56e97e00bd744400f3d35f1d6f032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf56e97e00bd744400f3d35f1d6f032">&#9670;&#160;</a></span>getTensor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudaq_1_1SimulationState_1_1Tensor.html">Tensor</a> <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::getTensor </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tensorIdx</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tensor at the given index. Throws for an invalid tensor index. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#a92bdff9f8c2fa8b0a4eb8b3bf6cb900a">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="af76f320bc44b49f22ea9cca308146e0b" name="af76f320bc44b49f22ea9cca308146e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76f320bc44b49f22ea9cca308146e0b">&#9670;&#160;</a></span>getTensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcudaq_1_1SimulationState_1_1Tensor.html">Tensor</a> &gt; <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::getTensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all tensors that represent this state. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#ae282133b9dcf7492881c2bd4702f4a69">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a87c779c25762e8aa3bb6be8f0e59e508" name="a87c779c25762e8aa3bb6be8f0e59e508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c779c25762e8aa3bb6be8f0e59e508">&#9670;&#160;</a></span>getNumTensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::getNumTensors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of tensors that represent this state. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#a9a2e7e11d1d38f8aac9f7b728258ed84">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a52f31b51fdfc0dee1f305ac03cda0809" name="a52f31b51fdfc0dee1f305ac03cda0809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f31b51fdfc0dee1f305ac03cda0809">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::complex&lt; double &gt; <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>tensorIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element from the tensor at the given tensor index and at the given indices. </p>

<p>Reimplemented from <a class="el" href="classcudaq_1_1SimulationState.html#ad4303d5f74509a13f94be5700b709d74">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="abff9c9093f8ee47ecafa8ff02d20111d" name="abff9c9093f8ee47ecafa8ff02d20111d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff9c9093f8ee47ecafa8ff02d20111d">&#9670;&#160;</a></span>toHost() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::toHost </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the state device data to the user-provided host data pointer. </p>

<p>Reimplemented from <a class="el" href="classcudaq_1_1SimulationState.html#a9176de37f8740e6e33415e183c24d447">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="ad3d96cc1f0b60e6953732be53bcfa3df" name="ad3d96cc1f0b60e6953732be53bcfa3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d96cc1f0b60e6953732be53bcfa3df">&#9670;&#160;</a></span>toHost() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::toHost </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; float &gt; *&#160;</td>
          <td class="paramname"><em>userData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the state device data to the user-provided host data pointer. </p>

<p>Reimplemented from <a class="el" href="classcudaq_1_1SimulationState.html#ace2d1f8d95c25f46ba515c2ecb79d1c5">cudaq::SimulationState</a>.</p>

</div>
</div>
<a id="a67ce242ebff2bd3f127c05320a27418e" name="a67ce242ebff2bd3f127c05320a27418e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ce242ebff2bd3f127c05320a27418e">&#9670;&#160;</a></span>destroyState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcudaq_1_1CusvState.html">cudaq::CusvState</a>&lt; ScalarType &gt;::destroyState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the device data. </p>

<p>Implements <a class="el" href="classcudaq_1_1SimulationState.html#acc6bd1e6a1827b12e4177d7b9e24ac3e">cudaq::SimulationState</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/cuda-quantum/runtime/nvqir/custatevec/<a class="el" href="CuStateVecState_8h_source.html">CuStateVecState.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
